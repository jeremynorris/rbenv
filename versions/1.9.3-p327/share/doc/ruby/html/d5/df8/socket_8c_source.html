<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ruby: ext/socket/socket.c Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>ext/socket/socket.c</h1><a href="../../d5/df8/socket_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">  socket.c -</span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">  created at: Thu Mar 31 12:21:29 JST 1994</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">  Copyright (C) 1993-2007 Yukihiro Matsumoto</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">************************************************/</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="../../dd/d8c/rubysocket_8h.html">rubysocket.h</a>&quot;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00014"></a><a class="code" href="../../d5/df8/socket_8c.html#a0364281f22964b6fab9131290d6abad1">00014</a> <a class="code" href="../../d5/df8/socket_8c.html#a0364281f22964b6fab9131290d6abad1">setup_domain_and_type</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> domain, <span class="keywordtype">int</span> *<a class="code" href="../../d6/da0/nkf-utf8_2nkf_8c.html#a555e4f17d8dc6f6cae4bcfd2dcbea9ce">dv</a>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <a class="code" href="../../d5/d9d/tcltklib_8c.html#ac765329451135abec74c45e1897abf26">type</a>, <span class="keywordtype">int</span> *tv)
<a name="l00015"></a>00015 {
<a name="l00016"></a>00016     *dv = <a class="code" href="../../d4/df3/constants_8c.html#a39ff0a7f7690b7524885e5140b588048">rsock_family_arg</a>(domain);
<a name="l00017"></a>00017     *tv = <a class="code" href="../../d4/df3/constants_8c.html#acd5c002b7516bd5262afd6fc4f71151c">rsock_socktype_arg</a>(type);
<a name="l00018"></a>00018 }
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/*</span>
<a name="l00021"></a>00021 <span class="comment"> * call-seq:</span>
<a name="l00022"></a>00022 <span class="comment"> *   Socket.new(domain, socktype [, protocol]) =&gt; socket</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * Creates a new socket object.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * _protocol_ should be a protocol defined in the domain.</span>
<a name="l00031"></a>00031 <span class="comment"> * This is optional.</span>
<a name="l00032"></a>00032 <span class="comment"> * If it is not given, 0 is used internally.</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> *   Socket.new(:INET, :STREAM) # TCP socket</span>
<a name="l00035"></a>00035 <span class="comment"> *   Socket.new(:INET, :DGRAM)  # UDP socket</span>
<a name="l00036"></a>00036 <span class="comment"> *   Socket.new(:UNIX, :STREAM) # UNIX stream socket</span>
<a name="l00037"></a>00037 <span class="comment"> *   Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket</span>
<a name="l00038"></a>00038 <span class="comment"> */</span>
<a name="l00039"></a>00039 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00040"></a><a class="code" href="../../d5/df8/socket_8c.html#ac836eb0f162ea2797f923d768002e6db">00040</a> <a class="code" href="../../d5/df8/socket_8c.html#ac836eb0f162ea2797f923d768002e6db">sock_initialize</a>(<span class="keywordtype">int</span> <a class="code" href="../../df/d77/ruby_8c.html#ad1447518f4372828b8435ae82e48499e">argc</a>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *<a class="code" href="../../df/d77/ruby_8c.html#af2efa898e9eed6fe6715279cb1ec35b0">argv</a>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock)
<a name="l00041"></a>00041 {
<a name="l00042"></a>00042     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> domain, <a class="code" href="../../d5/d9d/tcltklib_8c.html#ac765329451135abec74c45e1897abf26">type</a>, protocol;
<a name="l00043"></a>00043     <span class="keywordtype">int</span> fd;
<a name="l00044"></a>00044     <span class="keywordtype">int</span> d, t;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;21&quot;</span>, &amp;domain, &amp;type, &amp;protocol);
<a name="l00047"></a>00047     <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(protocol))
<a name="l00048"></a>00048         protocol = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(0);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a98b91af598acb64fe8497413ce498766">rb_secure</a>(3);
<a name="l00051"></a>00051     <a class="code" href="../../d5/df8/socket_8c.html#a0364281f22964b6fab9131290d6abad1">setup_domain_and_type</a>(domain, &amp;d, type, &amp;t);
<a name="l00052"></a>00052     fd = <a class="code" href="../../da/dcc/socket_2init_8c.html#a8bb5397bff51a073e7b6a1696b843a85">rsock_socket</a>(d, t, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a877c38180d23c5447d976c70dda89d69">NUM2INT</a>(protocol));
<a name="l00053"></a>00053     <span class="keywordflow">if</span> (fd &lt; 0) <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;socket(2)&quot;</span>);
<a name="l00054"></a>00054 
<a name="l00055"></a>00055     <span class="keywordflow">return</span> <a class="code" href="../../da/dcc/socket_2init_8c.html#a94cad3a347ec1301613b0d15aaa461ec">rsock_init_sock</a>(sock, fd);
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="preprocessor">#if defined HAVE_SOCKETPAIR</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00060"></a>00060 <a class="code" href="../../df/d0a/io_8c.html#a5a09b7d7498ee069ce6c420c90541092">io_call_close</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> io)
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a6a973fe624aa9aa9ba0cdeb6792d3187" title="Calls a method.">rb_funcall</a>(io, <a class="code" href="../../dc/dcc/array_8c.html#a9cfa42d4b79c89d68c53be8b2150a503">rb_intern</a>(<span class="stringliteral">&quot;close&quot;</span>), 0, 0);
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00066"></a>00066 <a class="code" href="../../df/d0a/io_8c.html#a7816bea23b5170be49ecb1a7ff8aafcf">io_close</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> io)
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068     <span class="keywordflow">return</span> <a class="code" href="../../d3/d57/eval_8c.html#a8935de1c570989c6ccc34d0336b2b75a">rb_rescue</a>(<a class="code" href="../../df/d0a/io_8c.html#a5a09b7d7498ee069ce6c420c90541092">io_call_close</a>, io, 0, 0);
<a name="l00069"></a>00069 }
<a name="l00070"></a>00070 
<a name="l00071"></a>00071 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00072"></a>00072 pair_yield(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> pair)
<a name="l00073"></a>00073 {
<a name="l00074"></a>00074     <span class="keywordflow">return</span> <a class="code" href="../../d3/d57/eval_8c.html#a8061198378fb16adeb931f90540b2839">rb_ensure</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#ae6bd0c4ea4db971ebd569ca8f05c6b4a">rb_yield</a>, pair, <a class="code" href="../../df/d0a/io_8c.html#a7816bea23b5170be49ecb1a7ff8aafcf">io_close</a>, <a class="code" href="../../dc/dcc/array_8c.html#ae3c2ac6c88e666d5418855114eb8bcf8">rb_ary_entry</a>(pair, 1));
<a name="l00075"></a>00075 }
<a name="l00076"></a>00076 <span class="preprocessor">#endif</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#if defined HAVE_SOCKETPAIR</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00080"></a>00080 <span class="comment"> * call-seq:</span>
<a name="l00081"></a>00081 <span class="comment"> *   Socket.pair(domain, type, protocol)       =&gt; [socket1, socket2]</span>
<a name="l00082"></a>00082 <span class="comment"> *   Socket.socketpair(domain, type, protocol) =&gt; [socket1, socket2]</span>
<a name="l00083"></a>00083 <span class="comment"> *</span>
<a name="l00084"></a>00084 <span class="comment"> * Creates a pair of sockets connected each other.</span>
<a name="l00085"></a>00085 <span class="comment"> *</span>
<a name="l00086"></a>00086 <span class="comment"> * _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.</span>
<a name="l00087"></a>00087 <span class="comment"> *</span>
<a name="l00088"></a>00088 <span class="comment"> * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</span>
<a name="l00089"></a>00089 <span class="comment"> *</span>
<a name="l00090"></a>00090 <span class="comment"> * _protocol_ should be a protocol defined in the domain.</span>
<a name="l00091"></a>00091 <span class="comment"> * 0 is default protocol for the domain.</span>
<a name="l00092"></a>00092 <span class="comment"> *</span>
<a name="l00093"></a>00093 <span class="comment"> *   s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)</span>
<a name="l00094"></a>00094 <span class="comment"> *   s1.send &quot;a&quot;, 0</span>
<a name="l00095"></a>00095 <span class="comment"> *   s1.send &quot;b&quot;, 0</span>
<a name="l00096"></a>00096 <span class="comment"> *   p s2.recv(10) #=&gt; &quot;a&quot;</span>
<a name="l00097"></a>00097 <span class="comment"> *   p s2.recv(10) #=&gt; &quot;b&quot;</span>
<a name="l00098"></a>00098 <span class="comment"> *</span>
<a name="l00099"></a>00099 <span class="comment"> */</span>
<a name="l00100"></a>00100 <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00101"></a>00101 <a class="code" href="../../d5/df8/socket_8c.html#a0627676d0b2c7f5831f2f42e482f531e">rsock_sock_s_socketpair</a>(<span class="keywordtype">int</span> <a class="code" href="../../df/d77/ruby_8c.html#ad1447518f4372828b8435ae82e48499e">argc</a>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *<a class="code" href="../../df/d77/ruby_8c.html#af2efa898e9eed6fe6715279cb1ec35b0">argv</a>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> klass)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> domain, <a class="code" href="../../d5/d9d/tcltklib_8c.html#ac765329451135abec74c45e1897abf26">type</a>, protocol;
<a name="l00104"></a>00104     <span class="keywordtype">int</span> d, t, p, sp[2];
<a name="l00105"></a>00105     <span class="keywordtype">int</span> ret;
<a name="l00106"></a>00106     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> s1, s2, r;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;21&quot;</span>, &amp;domain, &amp;type, &amp;protocol);
<a name="l00109"></a>00109     <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(protocol))
<a name="l00110"></a>00110         protocol = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(0);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112     <a class="code" href="../../d5/df8/socket_8c.html#a0364281f22964b6fab9131290d6abad1">setup_domain_and_type</a>(domain, &amp;d, type, &amp;t);
<a name="l00113"></a>00113     p = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a877c38180d23c5447d976c70dda89d69">NUM2INT</a>(protocol);
<a name="l00114"></a>00114     ret = socketpair(d, t, p, sp);
<a name="l00115"></a>00115     <span class="keywordflow">if</span> (ret &lt; 0 &amp;&amp; (errno == EMFILE || errno == ENFILE)) {
<a name="l00116"></a>00116         <a class="code" href="../../d8/d16/gc_8c.html#a7a12ca86b76e272a301173e7661acfea">rb_gc</a>();
<a name="l00117"></a>00117         ret = socketpair(d, t, p, sp);
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119     <span class="keywordflow">if</span> (ret &lt; 0) {
<a name="l00120"></a>00120         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;socketpair(2)&quot;</span>);
<a name="l00121"></a>00121     }
<a name="l00122"></a>00122     <a class="code" href="../../db/d2e/intern_8h.html#a6448f20b0936afe0cb85ab3186753db2">rb_update_max_fd</a>(sp[0]);
<a name="l00123"></a>00123     <a class="code" href="../../db/d2e/intern_8h.html#a6448f20b0936afe0cb85ab3186753db2">rb_update_max_fd</a>(sp[1]);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     s1 = <a class="code" href="../../da/dcc/socket_2init_8c.html#a94cad3a347ec1301613b0d15aaa461ec">rsock_init_sock</a>(<a class="code" href="../../db/d2e/intern_8h.html#a4419d9ed52af0d0dbdcb02f491b1d88d">rb_obj_alloc</a>(klass), sp[0]);
<a name="l00126"></a>00126     s2 = <a class="code" href="../../da/dcc/socket_2init_8c.html#a94cad3a347ec1301613b0d15aaa461ec">rsock_init_sock</a>(<a class="code" href="../../db/d2e/intern_8h.html#a4419d9ed52af0d0dbdcb02f491b1d88d">rb_obj_alloc</a>(klass), sp[1]);
<a name="l00127"></a>00127     r = <a class="code" href="../../dc/dcc/array_8c.html#af3085ceab406e3f4f4b90f383c440d6a">rb_assoc_new</a>(s1, s2);
<a name="l00128"></a>00128     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d57/eval_8c.html#aea346c4eb8bc06df88422e956bb05fec">rb_block_given_p</a>()) {
<a name="l00129"></a>00129         <span class="keywordflow">return</span> <a class="code" href="../../d3/d57/eval_8c.html#a8061198378fb16adeb931f90540b2839">rb_ensure</a>(pair_yield, r, <a class="code" href="../../df/d0a/io_8c.html#a7816bea23b5170be49ecb1a7ff8aafcf">io_close</a>, s1);
<a name="l00130"></a>00130     }
<a name="l00131"></a>00131     <span class="keywordflow">return</span> r;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 <span class="preprocessor">#else</span>
<a name="l00134"></a><a class="code" href="../../d5/df8/socket_8c.html#a0627676d0b2c7f5831f2f42e482f531e">00134</a> <span class="preprocessor"></span><span class="preprocessor">#define rsock_sock_s_socketpair rb_f_notimplement</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>
<a name="l00137"></a>00137 <span class="comment">/*</span>
<a name="l00138"></a>00138 <span class="comment"> * call-seq:</span>
<a name="l00139"></a>00139 <span class="comment"> *      socket.connect(remote_sockaddr) =&gt; 0</span>
<a name="l00140"></a>00140 <span class="comment"> *</span>
<a name="l00141"></a>00141 <span class="comment"> * Requests a connection to be made on the given +remote_sockaddr+. Returns 0 if</span>
<a name="l00142"></a>00142 <span class="comment"> * successful, otherwise an exception is raised.</span>
<a name="l00143"></a>00143 <span class="comment"> *</span>
<a name="l00144"></a>00144 <span class="comment"> * === Parameter</span>
<a name="l00145"></a>00145 <span class="comment"> * * +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object</span>
<a name="l00146"></a>00146 <span class="comment"> *</span>
<a name="l00147"></a>00147 <span class="comment"> * === Example:</span>
<a name="l00148"></a>00148 <span class="comment"> *      # Pull down Google&apos;s web page</span>
<a name="l00149"></a>00149 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00150"></a>00150 <span class="comment"> *      include Socket::Constants</span>
<a name="l00151"></a>00151 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00152"></a>00152 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 80, &apos;www.google.com&apos; )</span>
<a name="l00153"></a>00153 <span class="comment"> *      socket.connect( sockaddr )</span>
<a name="l00154"></a>00154 <span class="comment"> *      socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )</span>
<a name="l00155"></a>00155 <span class="comment"> *      results = socket.read</span>
<a name="l00156"></a>00156 <span class="comment"> *</span>
<a name="l00157"></a>00157 <span class="comment"> * === Unix-based Exceptions</span>
<a name="l00158"></a>00158 <span class="comment"> * On unix-based systems the following system exceptions may be raised if</span>
<a name="l00159"></a>00159 <span class="comment"> * the call to _connect_ fails:</span>
<a name="l00160"></a>00160 <span class="comment"> * * Errno::EACCES - search permission is denied for a component of the prefix</span>
<a name="l00161"></a>00161 <span class="comment"> *   path or write access to the +socket+ is denied</span>
<a name="l00162"></a>00162 <span class="comment"> * * Errno::EADDRINUSE - the _sockaddr_ is already in use</span>
<a name="l00163"></a>00163 <span class="comment"> * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the</span>
<a name="l00164"></a>00164 <span class="comment"> *   local machine</span>
<a name="l00165"></a>00165 <span class="comment"> * * Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for</span>
<a name="l00166"></a>00166 <span class="comment"> *   the address family of the specified +socket+</span>
<a name="l00167"></a>00167 <span class="comment"> * * Errno::EALREADY - a connection is already in progress for the specified</span>
<a name="l00168"></a>00168 <span class="comment"> *   socket</span>
<a name="l00169"></a>00169 <span class="comment"> * * Errno::EBADF - the +socket+ is not a valid file descriptor</span>
<a name="l00170"></a>00170 <span class="comment"> * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections</span>
<a name="l00171"></a>00171 <span class="comment"> *   refused the connection request</span>
<a name="l00172"></a>00172 <span class="comment"> * * Errno::ECONNRESET - the remote host reset the connection request</span>
<a name="l00173"></a>00173 <span class="comment"> * * Errno::EFAULT - the _sockaddr_ cannot be accessed</span>
<a name="l00174"></a>00174 <span class="comment"> * * Errno::EHOSTUNREACH - the destination host cannot be reached (probably</span>
<a name="l00175"></a>00175 <span class="comment"> *   because the host is down or a remote router cannot reach it)</span>
<a name="l00176"></a>00176 <span class="comment"> * * Errno::EINPROGRESS - the O_NONBLOCK is set for the +socket+ and the</span>
<a name="l00177"></a>00177 <span class="comment"> *   connection cannot be immediately established; the connection will be</span>
<a name="l00178"></a>00178 <span class="comment"> *   established asynchronously</span>
<a name="l00179"></a>00179 <span class="comment"> * * Errno::EINTR - the attempt to establish the connection was interrupted by</span>
<a name="l00180"></a>00180 <span class="comment"> *   delivery of a signal that was caught; the connection will be established</span>
<a name="l00181"></a>00181 <span class="comment"> *   asynchronously</span>
<a name="l00182"></a>00182 <span class="comment"> * * Errno::EISCONN - the specified +socket+ is already connected</span>
<a name="l00183"></a>00183 <span class="comment"> * * Errno::EINVAL - the address length used for the _sockaddr_ is not a valid</span>
<a name="l00184"></a>00184 <span class="comment"> *   length for the address family or there is an invalid family in _sockaddr_</span>
<a name="l00185"></a>00185 <span class="comment"> * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded</span>
<a name="l00186"></a>00186 <span class="comment"> *   PATH_MAX</span>
<a name="l00187"></a>00187 <span class="comment"> * * Errno::ENETDOWN - the local interface used to reach the destination is down</span>
<a name="l00188"></a>00188 <span class="comment"> * * Errno::ENETUNREACH - no route to the network is present</span>
<a name="l00189"></a>00189 <span class="comment"> * * Errno::ENOBUFS - no buffer space is available</span>
<a name="l00190"></a>00190 <span class="comment"> * * Errno::ENOSR - there were insufficient STREAMS resources available to</span>
<a name="l00191"></a>00191 <span class="comment"> *   complete the operation</span>
<a name="l00192"></a>00192 <span class="comment"> * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket</span>
<a name="l00193"></a>00193 <span class="comment"> * * Errno::EOPNOTSUPP - the calling +socket+ is listening and cannot be connected</span>
<a name="l00194"></a>00194 <span class="comment"> * * Errno::EPROTOTYPE - the _sockaddr_ has a different type than the socket</span>
<a name="l00195"></a>00195 <span class="comment"> *   bound to the specified peer address</span>
<a name="l00196"></a>00196 <span class="comment"> * * Errno::ETIMEDOUT - the attempt to connect time out before a connection</span>
<a name="l00197"></a>00197 <span class="comment"> *   was made.</span>
<a name="l00198"></a>00198 <span class="comment"> *</span>
<a name="l00199"></a>00199 <span class="comment"> * On unix-based systems if the address family of the calling +socket+ is</span>
<a name="l00200"></a>00200 <span class="comment"> * AF_UNIX the follow exceptions may be raised if the call to _connect_</span>
<a name="l00201"></a>00201 <span class="comment"> * fails:</span>
<a name="l00202"></a>00202 <span class="comment"> * * Errno::EIO - an i/o error occurred while reading from or writing to the</span>
<a name="l00203"></a>00203 <span class="comment"> *   file system</span>
<a name="l00204"></a>00204 <span class="comment"> * * Errno::ELOOP - too many symbolic links were encountered in translating</span>
<a name="l00205"></a>00205 <span class="comment"> *   the pathname in _sockaddr_</span>
<a name="l00206"></a>00206 <span class="comment"> * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX</span>
<a name="l00207"></a>00207 <span class="comment"> *   characters, or an entire pathname exceeded PATH_MAX characters</span>
<a name="l00208"></a>00208 <span class="comment"> * * Errno::ENOENT - a component of the pathname does not name an existing file</span>
<a name="l00209"></a>00209 <span class="comment"> *   or the pathname is an empty string</span>
<a name="l00210"></a>00210 <span class="comment"> * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_</span>
<a name="l00211"></a>00211 <span class="comment"> *   is not a directory</span>
<a name="l00212"></a>00212 <span class="comment"> *</span>
<a name="l00213"></a>00213 <span class="comment"> * === Windows Exceptions</span>
<a name="l00214"></a>00214 <span class="comment"> * On Windows systems the following system exceptions may be raised if</span>
<a name="l00215"></a>00215 <span class="comment"> * the call to _connect_ fails:</span>
<a name="l00216"></a>00216 <span class="comment"> * * Errno::ENETDOWN - the network is down</span>
<a name="l00217"></a>00217 <span class="comment"> * * Errno::EADDRINUSE - the socket&apos;s local address is already in use</span>
<a name="l00218"></a>00218 <span class="comment"> * * Errno::EINTR - the socket was cancelled</span>
<a name="l00219"></a>00219 <span class="comment"> * * Errno::EINPROGRESS - a blocking socket is in progress or the service provider</span>
<a name="l00220"></a>00220 <span class="comment"> *   is still processing a callback function. Or a nonblocking connect call is</span>
<a name="l00221"></a>00221 <span class="comment"> *   in progress on the +socket+.</span>
<a name="l00222"></a>00222 <span class="comment"> * * Errno::EALREADY - see Errno::EINVAL</span>
<a name="l00223"></a>00223 <span class="comment"> * * Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as</span>
<a name="l00224"></a>00224 <span class="comment"> *   ADDR_ANY TODO check ADDRANY TO INADDR_ANY</span>
<a name="l00225"></a>00225 <span class="comment"> * * Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with</span>
<a name="l00226"></a>00226 <span class="comment"> *   with this +socket+</span>
<a name="l00227"></a>00227 <span class="comment"> * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections</span>
<a name="l00228"></a>00228 <span class="comment"> *   refused the connection request</span>
<a name="l00229"></a>00229 <span class="comment"> * * Errno::EFAULT - the socket&apos;s internal address or address length parameter</span>
<a name="l00230"></a>00230 <span class="comment"> *   is too small or is not a valid part of the user space address</span>
<a name="l00231"></a>00231 <span class="comment"> * * Errno::EINVAL - the +socket+ is a listening socket</span>
<a name="l00232"></a>00232 <span class="comment"> * * Errno::EISCONN - the +socket+ is already connected</span>
<a name="l00233"></a>00233 <span class="comment"> * * Errno::ENETUNREACH - the network cannot be reached from this host at this time</span>
<a name="l00234"></a>00234 <span class="comment"> * * Errno::EHOSTUNREACH - no route to the network is present</span>
<a name="l00235"></a>00235 <span class="comment"> * * Errno::ENOBUFS - no buffer space is available</span>
<a name="l00236"></a>00236 <span class="comment"> * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket</span>
<a name="l00237"></a>00237 <span class="comment"> * * Errno::ETIMEDOUT - the attempt to connect time out before a connection</span>
<a name="l00238"></a>00238 <span class="comment"> *   was made.</span>
<a name="l00239"></a>00239 <span class="comment"> * * Errno::EWOULDBLOCK - the socket is marked as nonblocking and the</span>
<a name="l00240"></a>00240 <span class="comment"> *   connection cannot be completed immediately</span>
<a name="l00241"></a>00241 <span class="comment"> * * Errno::EACCES - the attempt to connect the datagram socket to the</span>
<a name="l00242"></a>00242 <span class="comment"> *   broadcast address failed</span>
<a name="l00243"></a>00243 <span class="comment"> *</span>
<a name="l00244"></a>00244 <span class="comment"> * === See</span>
<a name="l00245"></a>00245 <span class="comment"> * * connect manual pages on unix-based systems</span>
<a name="l00246"></a>00246 <span class="comment"> * * connect function in Microsoft&apos;s Winsock functions reference</span>
<a name="l00247"></a>00247 <span class="comment"> */</span>
<a name="l00248"></a>00248 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00249"></a><a class="code" href="../../d5/df8/socket_8c.html#ae85c71a1788d42c28521462616cc894a">00249</a> <a class="code" href="../../d5/df8/socket_8c.html#ae85c71a1788d42c28521462616cc894a">sock_connect</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr)
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00252"></a>00252     <span class="keywordtype">int</span> fd, n;
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     <a class="code" href="../../dd/d8c/rubysocket_8h.html#a188d3d6216d270e123dc67bc8b57a049">SockAddrStringValue</a>(addr);
<a name="l00255"></a>00255     addr = <a class="code" href="../../db/d2e/intern_8h.html#af609add406b0ef084a38f6dd615119d6">rb_str_new4</a>(addr);
<a name="l00256"></a>00256     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00257"></a>00257     fd = fptr-&gt;<a class="code" href="../../dd/d7e/structrb__io__t.html#a0d48f8e91d24ff4f382564b30c1b41c2">fd</a>;
<a name="l00258"></a>00258     n = <a class="code" href="../../da/dcc/socket_2init_8c.html#ae6a2161106bd94d8cdd216a05fd7226c">rsock_connect</a>(fd, (<span class="keyword">struct</span> sockaddr*)<a class="code" href="../../d8/df4/generator_8h.html#aa0c7097c0d82c8372072fbab5a604e39">RSTRING_PTR</a>(addr), <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a5133348f689646af76f8fe8e0af547f5">RSTRING_LENINT</a>(addr), 0);
<a name="l00259"></a>00259     <span class="keywordflow">if</span> (n &lt; 0) {
<a name="l00260"></a>00260         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;connect(2)&quot;</span>);
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(n);
<a name="l00264"></a>00264 }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="comment">/*</span>
<a name="l00267"></a>00267 <span class="comment"> * call-seq:</span>
<a name="l00268"></a>00268 <span class="comment"> *      socket.connect_nonblock(remote_sockaddr) =&gt; 0</span>
<a name="l00269"></a>00269 <span class="comment"> *</span>
<a name="l00270"></a>00270 <span class="comment"> * Requests a connection to be made on the given +remote_sockaddr+ after</span>
<a name="l00271"></a>00271 <span class="comment"> * O_NONBLOCK is set for the underlying file descriptor.</span>
<a name="l00272"></a>00272 <span class="comment"> * Returns 0 if successful, otherwise an exception is raised.</span>
<a name="l00273"></a>00273 <span class="comment"> *</span>
<a name="l00274"></a>00274 <span class="comment"> * === Parameter</span>
<a name="l00275"></a>00275 <span class="comment"> * * +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object</span>
<a name="l00276"></a>00276 <span class="comment"> *</span>
<a name="l00277"></a>00277 <span class="comment"> * === Example:</span>
<a name="l00278"></a>00278 <span class="comment"> *      # Pull down Google&apos;s web page</span>
<a name="l00279"></a>00279 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00280"></a>00280 <span class="comment"> *      include Socket::Constants</span>
<a name="l00281"></a>00281 <span class="comment"> *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)</span>
<a name="l00282"></a>00282 <span class="comment"> *      sockaddr = Socket.sockaddr_in(80, &apos;www.google.com&apos;)</span>
<a name="l00283"></a>00283 <span class="comment"> *      begin # emulate blocking connect</span>
<a name="l00284"></a>00284 <span class="comment"> *        socket.connect_nonblock(sockaddr)</span>
<a name="l00285"></a>00285 <span class="comment"> *      rescue IO::WaitWritable</span>
<a name="l00286"></a>00286 <span class="comment"> *        IO.select(nil, [socket]) # wait 3-way handshake completion</span>
<a name="l00287"></a>00287 <span class="comment"> *        begin</span>
<a name="l00288"></a>00288 <span class="comment"> *          socket.connect_nonblock(sockaddr) # check connection failure</span>
<a name="l00289"></a>00289 <span class="comment"> *        rescue Errno::EISCONN</span>
<a name="l00290"></a>00290 <span class="comment"> *        end</span>
<a name="l00291"></a>00291 <span class="comment"> *      end</span>
<a name="l00292"></a>00292 <span class="comment"> *      socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)</span>
<a name="l00293"></a>00293 <span class="comment"> *      results = socket.read</span>
<a name="l00294"></a>00294 <span class="comment"> *</span>
<a name="l00295"></a>00295 <span class="comment"> * Refer to Socket#connect for the exceptions that may be thrown if the call</span>
<a name="l00296"></a>00296 <span class="comment"> * to _connect_nonblock_ fails.</span>
<a name="l00297"></a>00297 <span class="comment"> *</span>
<a name="l00298"></a>00298 <span class="comment"> * Socket#connect_nonblock may raise any error corresponding to connect(2) failure,</span>
<a name="l00299"></a>00299 <span class="comment"> * including Errno::EINPROGRESS.</span>
<a name="l00300"></a>00300 <span class="comment"> *</span>
<a name="l00301"></a>00301 <span class="comment"> * If the exception is Errno::EINPROGRESS,</span>
<a name="l00302"></a>00302 <span class="comment"> * it is extended by IO::WaitWritable.</span>
<a name="l00303"></a>00303 <span class="comment"> * So IO::WaitWritable can be used to rescue the exceptions for retrying connect_nonblock.</span>
<a name="l00304"></a>00304 <span class="comment"> *</span>
<a name="l00305"></a>00305 <span class="comment"> * === See</span>
<a name="l00306"></a>00306 <span class="comment"> * * Socket#connect</span>
<a name="l00307"></a>00307 <span class="comment"> */</span>
<a name="l00308"></a>00308 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00309"></a><a class="code" href="../../d5/df8/socket_8c.html#a0b3a834fdc9dc7f0621e382111736ec4">00309</a> <a class="code" href="../../d5/df8/socket_8c.html#a0b3a834fdc9dc7f0621e382111736ec4">sock_connect_nonblock</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00312"></a>00312     <span class="keywordtype">int</span> n;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     <a class="code" href="../../dd/d8c/rubysocket_8h.html#a188d3d6216d270e123dc67bc8b57a049">SockAddrStringValue</a>(addr);
<a name="l00315"></a>00315     addr = <a class="code" href="../../db/d2e/intern_8h.html#af609add406b0ef084a38f6dd615119d6">rb_str_new4</a>(addr);
<a name="l00316"></a>00316     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00317"></a>00317     <a class="code" href="../../dc/dac/io_8h.html#ad3cd1cfd937d36dfeb7d0f2f4aeb08ab">rb_io_set_nonblock</a>(fptr);
<a name="l00318"></a>00318     n = connect(fptr-&gt;<a class="code" href="../../dd/d7e/structrb__io__t.html#a0d48f8e91d24ff4f382564b30c1b41c2">fd</a>, (<span class="keyword">struct</span> sockaddr*)<a class="code" href="../../d8/df4/generator_8h.html#aa0c7097c0d82c8372072fbab5a604e39">RSTRING_PTR</a>(addr), <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a5133348f689646af76f8fe8e0af547f5">RSTRING_LENINT</a>(addr));
<a name="l00319"></a>00319     <span class="keywordflow">if</span> (n &lt; 0) {
<a name="l00320"></a>00320         <span class="keywordflow">if</span> (<a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a> == <a class="code" href="../../dc/db1/win32_8h.html#a6c045d5be06e715cc335784a7320714e">EINPROGRESS</a>)
<a name="l00321"></a>00321             <a class="code" href="../../db/dcc/error_8c.html#a2087f7e18da9f5eec20b6e36b56d71ee">rb_mod_sys_fail</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac0e6048c512add5b6659c01f7f134d8a">rb_mWaitWritable</a>, <span class="stringliteral">&quot;connect(2) would block&quot;</span>);
<a name="l00322"></a>00322         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;connect(2)&quot;</span>);
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(n);
<a name="l00326"></a>00326 }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">/*</span>
<a name="l00329"></a>00329 <span class="comment"> * call-seq:</span>
<a name="l00330"></a>00330 <span class="comment"> *      socket.bind(local_sockaddr) =&gt; 0</span>
<a name="l00331"></a>00331 <span class="comment"> *</span>
<a name="l00332"></a>00332 <span class="comment"> * Binds to the given local address.</span>
<a name="l00333"></a>00333 <span class="comment"> *</span>
<a name="l00334"></a>00334 <span class="comment"> * === Parameter</span>
<a name="l00335"></a>00335 <span class="comment"> * * +local_sockaddr+ - the +struct+ sockaddr contained in a string or an Addrinfo object</span>
<a name="l00336"></a>00336 <span class="comment"> *</span>
<a name="l00337"></a>00337 <span class="comment"> * === Example</span>
<a name="l00338"></a>00338 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00339"></a>00339 <span class="comment"> *</span>
<a name="l00340"></a>00340 <span class="comment"> *      # use Addrinfo</span>
<a name="l00341"></a>00341 <span class="comment"> *      socket = Socket.new(:INET, :STREAM, 0)</span>
<a name="l00342"></a>00342 <span class="comment"> *      socket.bind(Addrinfo.tcp(&quot;127.0.0.1&quot;, 2222))</span>
<a name="l00343"></a>00343 <span class="comment"> *      p socket.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:2222 TCP&gt;</span>
<a name="l00344"></a>00344 <span class="comment"> *</span>
<a name="l00345"></a>00345 <span class="comment"> *      # use struct sockaddr</span>
<a name="l00346"></a>00346 <span class="comment"> *      include Socket::Constants</span>
<a name="l00347"></a>00347 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00348"></a>00348 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )</span>
<a name="l00349"></a>00349 <span class="comment"> *      socket.bind( sockaddr )</span>
<a name="l00350"></a>00350 <span class="comment"> *</span>
<a name="l00351"></a>00351 <span class="comment"> * === Unix-based Exceptions</span>
<a name="l00352"></a>00352 <span class="comment"> * On unix-based based systems the following system exceptions may be raised if</span>
<a name="l00353"></a>00353 <span class="comment"> * the call to _bind_ fails:</span>
<a name="l00354"></a>00354 <span class="comment"> * * Errno::EACCES - the specified _sockaddr_ is protected and the current</span>
<a name="l00355"></a>00355 <span class="comment"> *   user does not have permission to bind to it</span>
<a name="l00356"></a>00356 <span class="comment"> * * Errno::EADDRINUSE - the specified _sockaddr_ is already in use</span>
<a name="l00357"></a>00357 <span class="comment"> * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the</span>
<a name="l00358"></a>00358 <span class="comment"> *   local machine</span>
<a name="l00359"></a>00359 <span class="comment"> * * Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for</span>
<a name="l00360"></a>00360 <span class="comment"> *   the family of the calling +socket+</span>
<a name="l00361"></a>00361 <span class="comment"> * * Errno::EBADF - the _sockaddr_ specified is not a valid file descriptor</span>
<a name="l00362"></a>00362 <span class="comment"> * * Errno::EFAULT - the _sockaddr_ argument cannot be accessed</span>
<a name="l00363"></a>00363 <span class="comment"> * * Errno::EINVAL - the +socket+ is already bound to an address, and the</span>
<a name="l00364"></a>00364 <span class="comment"> *   protocol does not support binding to the new _sockaddr_ or the +socket+</span>
<a name="l00365"></a>00365 <span class="comment"> *   has been shut down.</span>
<a name="l00366"></a>00366 <span class="comment"> * * Errno::EINVAL - the address length is not a valid length for the address</span>
<a name="l00367"></a>00367 <span class="comment"> *   family</span>
<a name="l00368"></a>00368 <span class="comment"> * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded</span>
<a name="l00369"></a>00369 <span class="comment"> *   PATH_MAX</span>
<a name="l00370"></a>00370 <span class="comment"> * * Errno::ENOBUFS - no buffer space is available</span>
<a name="l00371"></a>00371 <span class="comment"> * * Errno::ENOSR - there were insufficient STREAMS resources available to</span>
<a name="l00372"></a>00372 <span class="comment"> *   complete the operation</span>
<a name="l00373"></a>00373 <span class="comment"> * * Errno::ENOTSOCK - the +socket+ does not refer to a socket</span>
<a name="l00374"></a>00374 <span class="comment"> * * Errno::EOPNOTSUPP - the socket type of the +socket+ does not support</span>
<a name="l00375"></a>00375 <span class="comment"> *   binding to an address</span>
<a name="l00376"></a>00376 <span class="comment"> *</span>
<a name="l00377"></a>00377 <span class="comment"> * On unix-based based systems if the address family of the calling +socket+ is</span>
<a name="l00378"></a>00378 <span class="comment"> * Socket::AF_UNIX the follow exceptions may be raised if the call to _bind_</span>
<a name="l00379"></a>00379 <span class="comment"> * fails:</span>
<a name="l00380"></a>00380 <span class="comment"> * * Errno::EACCES - search permission is denied for a component of the prefix</span>
<a name="l00381"></a>00381 <span class="comment"> *   path or write access to the +socket+ is denied</span>
<a name="l00382"></a>00382 <span class="comment"> * * Errno::EDESTADDRREQ - the _sockaddr_ argument is a null pointer</span>
<a name="l00383"></a>00383 <span class="comment"> * * Errno::EISDIR - same as Errno::EDESTADDRREQ</span>
<a name="l00384"></a>00384 <span class="comment"> * * Errno::EIO - an i/o error occurred</span>
<a name="l00385"></a>00385 <span class="comment"> * * Errno::ELOOP - too many symbolic links were encountered in translating</span>
<a name="l00386"></a>00386 <span class="comment"> *   the pathname in _sockaddr_</span>
<a name="l00387"></a>00387 <span class="comment"> * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX</span>
<a name="l00388"></a>00388 <span class="comment"> *   characters, or an entire pathname exceeded PATH_MAX characters</span>
<a name="l00389"></a>00389 <span class="comment"> * * Errno::ENOENT - a component of the pathname does not name an existing file</span>
<a name="l00390"></a>00390 <span class="comment"> *   or the pathname is an empty string</span>
<a name="l00391"></a>00391 <span class="comment"> * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_</span>
<a name="l00392"></a>00392 <span class="comment"> *   is not a directory</span>
<a name="l00393"></a>00393 <span class="comment"> * * Errno::EROFS - the name would reside on a read only filesystem</span>
<a name="l00394"></a>00394 <span class="comment"> *</span>
<a name="l00395"></a>00395 <span class="comment"> * === Windows Exceptions</span>
<a name="l00396"></a>00396 <span class="comment"> * On Windows systems the following system exceptions may be raised if</span>
<a name="l00397"></a>00397 <span class="comment"> * the call to _bind_ fails:</span>
<a name="l00398"></a>00398 <span class="comment"> * * Errno::ENETDOWN-- the network is down</span>
<a name="l00399"></a>00399 <span class="comment"> * * Errno::EACCES - the attempt to connect the datagram socket to the</span>
<a name="l00400"></a>00400 <span class="comment"> *   broadcast address failed</span>
<a name="l00401"></a>00401 <span class="comment"> * * Errno::EADDRINUSE - the socket&apos;s local address is already in use</span>
<a name="l00402"></a>00402 <span class="comment"> * * Errno::EADDRNOTAVAIL - the specified address is not a valid address for this</span>
<a name="l00403"></a>00403 <span class="comment"> *   computer</span>
<a name="l00404"></a>00404 <span class="comment"> * * Errno::EFAULT - the socket&apos;s internal address or address length parameter</span>
<a name="l00405"></a>00405 <span class="comment"> *   is too small or is not a valid part of the user space addressed</span>
<a name="l00406"></a>00406 <span class="comment"> * * Errno::EINVAL - the +socket+ is already bound to an address</span>
<a name="l00407"></a>00407 <span class="comment"> * * Errno::ENOBUFS - no buffer space is available</span>
<a name="l00408"></a>00408 <span class="comment"> * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket</span>
<a name="l00409"></a>00409 <span class="comment"> *</span>
<a name="l00410"></a>00410 <span class="comment"> * === See</span>
<a name="l00411"></a>00411 <span class="comment"> * * bind manual pages on unix-based systems</span>
<a name="l00412"></a>00412 <span class="comment"> * * bind function in Microsoft&apos;s Winsock functions reference</span>
<a name="l00413"></a>00413 <span class="comment"> */</span>
<a name="l00414"></a>00414 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00415"></a><a class="code" href="../../d5/df8/socket_8c.html#a7a596462d1d632b3d82710985bb1c86f">00415</a> <a class="code" href="../../d5/df8/socket_8c.html#a7a596462d1d632b3d82710985bb1c86f">sock_bind</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr)
<a name="l00416"></a>00416 {
<a name="l00417"></a>00417     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     <a class="code" href="../../dd/d8c/rubysocket_8h.html#a188d3d6216d270e123dc67bc8b57a049">SockAddrStringValue</a>(addr);
<a name="l00420"></a>00420     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (bind(fptr-&gt;<a class="code" href="../../dd/d7e/structrb__io__t.html#a0d48f8e91d24ff4f382564b30c1b41c2">fd</a>, (<span class="keyword">struct</span> sockaddr*)<a class="code" href="../../d8/df4/generator_8h.html#aa0c7097c0d82c8372072fbab5a604e39">RSTRING_PTR</a>(addr), <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a5133348f689646af76f8fe8e0af547f5">RSTRING_LENINT</a>(addr)) &lt; 0)
<a name="l00422"></a>00422         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;bind(2)&quot;</span>);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(0);
<a name="l00425"></a>00425 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 <span class="comment">/*</span>
<a name="l00428"></a>00428 <span class="comment"> * call-seq:</span>
<a name="l00429"></a>00429 <span class="comment"> *      socket.listen( int ) =&gt; 0</span>
<a name="l00430"></a>00430 <span class="comment"> *</span>
<a name="l00431"></a>00431 <span class="comment"> * Listens for connections, using the specified +int+ as the backlog. A call</span>
<a name="l00432"></a>00432 <span class="comment"> * to _listen_ only applies if the +socket+ is of type SOCK_STREAM or</span>
<a name="l00433"></a>00433 <span class="comment"> * SOCK_SEQPACKET.</span>
<a name="l00434"></a>00434 <span class="comment"> *</span>
<a name="l00435"></a>00435 <span class="comment"> * === Parameter</span>
<a name="l00436"></a>00436 <span class="comment"> * * +backlog+ - the maximum length of the queue for pending connections.</span>
<a name="l00437"></a>00437 <span class="comment"> *</span>
<a name="l00438"></a>00438 <span class="comment"> * === Example 1</span>
<a name="l00439"></a>00439 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00440"></a>00440 <span class="comment"> *      include Socket::Constants</span>
<a name="l00441"></a>00441 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00442"></a>00442 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )</span>
<a name="l00443"></a>00443 <span class="comment"> *      socket.bind( sockaddr )</span>
<a name="l00444"></a>00444 <span class="comment"> *      socket.listen( 5 )</span>
<a name="l00445"></a>00445 <span class="comment"> *</span>
<a name="l00446"></a>00446 <span class="comment"> * === Example 2 (listening on an arbitrary port, unix-based systems only):</span>
<a name="l00447"></a>00447 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00448"></a>00448 <span class="comment"> *      include Socket::Constants</span>
<a name="l00449"></a>00449 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00450"></a>00450 <span class="comment"> *      socket.listen( 1 )</span>
<a name="l00451"></a>00451 <span class="comment"> *</span>
<a name="l00452"></a>00452 <span class="comment"> * === Unix-based Exceptions</span>
<a name="l00453"></a>00453 <span class="comment"> * On unix based systems the above will work because a new +sockaddr+ struct</span>
<a name="l00454"></a>00454 <span class="comment"> * is created on the address ADDR_ANY, for an arbitrary port number as handed</span>
<a name="l00455"></a>00455 <span class="comment"> * off by the kernel. It will not work on Windows, because Windows requires that</span>
<a name="l00456"></a>00456 <span class="comment"> * the +socket+ is bound by calling _bind_ before it can _listen_.</span>
<a name="l00457"></a>00457 <span class="comment"> *</span>
<a name="l00458"></a>00458 <span class="comment"> * If the _backlog_ amount exceeds the implementation-dependent maximum</span>
<a name="l00459"></a>00459 <span class="comment"> * queue length, the implementation&apos;s maximum queue length will be used.</span>
<a name="l00460"></a>00460 <span class="comment"> *</span>
<a name="l00461"></a>00461 <span class="comment"> * On unix-based based systems the following system exceptions may be raised if the</span>
<a name="l00462"></a>00462 <span class="comment"> * call to _listen_ fails:</span>
<a name="l00463"></a>00463 <span class="comment"> * * Errno::EBADF - the _socket_ argument is not a valid file descriptor</span>
<a name="l00464"></a>00464 <span class="comment"> * * Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and</span>
<a name="l00465"></a>00465 <span class="comment"> *   the protocol does not support listening on an unbound socket</span>
<a name="l00466"></a>00466 <span class="comment"> * * Errno::EINVAL - the _socket_ is already connected</span>
<a name="l00467"></a>00467 <span class="comment"> * * Errno::ENOTSOCK - the _socket_ argument does not refer to a socket</span>
<a name="l00468"></a>00468 <span class="comment"> * * Errno::EOPNOTSUPP - the _socket_ protocol does not support listen</span>
<a name="l00469"></a>00469 <span class="comment"> * * Errno::EACCES - the calling process does not have appropriate privileges</span>
<a name="l00470"></a>00470 <span class="comment"> * * Errno::EINVAL - the _socket_ has been shut down</span>
<a name="l00471"></a>00471 <span class="comment"> * * Errno::ENOBUFS - insufficient resources are available in the system to</span>
<a name="l00472"></a>00472 <span class="comment"> *   complete the call</span>
<a name="l00473"></a>00473 <span class="comment"> *</span>
<a name="l00474"></a>00474 <span class="comment"> * === Windows Exceptions</span>
<a name="l00475"></a>00475 <span class="comment"> * On Windows systems the following system exceptions may be raised if</span>
<a name="l00476"></a>00476 <span class="comment"> * the call to _listen_ fails:</span>
<a name="l00477"></a>00477 <span class="comment"> * * Errno::ENETDOWN - the network is down</span>
<a name="l00478"></a>00478 <span class="comment"> * * Errno::EADDRINUSE - the socket&apos;s local address is already in use. This</span>
<a name="l00479"></a>00479 <span class="comment"> *   usually occurs during the execution of _bind_ but could be delayed</span>
<a name="l00480"></a>00480 <span class="comment"> *   if the call to _bind_ was to a partially wildcard address (involving</span>
<a name="l00481"></a>00481 <span class="comment"> *   ADDR_ANY) and if a specific address needs to be committed at the</span>
<a name="l00482"></a>00482 <span class="comment"> *   time of the call to _listen_</span>
<a name="l00483"></a>00483 <span class="comment"> * * Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the</span>
<a name="l00484"></a>00484 <span class="comment"> *   service provider is still processing a callback function</span>
<a name="l00485"></a>00485 <span class="comment"> * * Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.</span>
<a name="l00486"></a>00486 <span class="comment"> * * Errno::EISCONN - the +socket+ is already connected</span>
<a name="l00487"></a>00487 <span class="comment"> * * Errno::EMFILE - no more socket descriptors are available</span>
<a name="l00488"></a>00488 <span class="comment"> * * Errno::ENOBUFS - no buffer space is available</span>
<a name="l00489"></a>00489 <span class="comment"> * * Errno::ENOTSOC - +socket+ is not a socket</span>
<a name="l00490"></a>00490 <span class="comment"> * * Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports</span>
<a name="l00491"></a>00491 <span class="comment"> *   the _listen_ method</span>
<a name="l00492"></a>00492 <span class="comment"> *</span>
<a name="l00493"></a>00493 <span class="comment"> * === See</span>
<a name="l00494"></a>00494 <span class="comment"> * * listen manual pages on unix-based systems</span>
<a name="l00495"></a>00495 <span class="comment"> * * listen function in Microsoft&apos;s Winsock functions reference</span>
<a name="l00496"></a>00496 <span class="comment"> */</span>
<a name="l00497"></a>00497 <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00498"></a><a class="code" href="../../d5/df8/socket_8c.html#acd4ebfc5cf43a6c4148cce15ada4cce3">00498</a> <a class="code" href="../../dd/d8c/rubysocket_8h.html#acd4ebfc5cf43a6c4148cce15ada4cce3">rsock_sock_listen</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> log)
<a name="l00499"></a>00499 {
<a name="l00500"></a>00500     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00501"></a>00501     <span class="keywordtype">int</span> backlog;
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a98b91af598acb64fe8497413ce498766">rb_secure</a>(4);
<a name="l00504"></a>00504     backlog = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a877c38180d23c5447d976c70dda89d69">NUM2INT</a>(log);
<a name="l00505"></a>00505     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00506"></a>00506     <span class="keywordflow">if</span> (listen(fptr-&gt;<a class="code" href="../../dd/d7e/structrb__io__t.html#a0d48f8e91d24ff4f382564b30c1b41c2">fd</a>, backlog) &lt; 0)
<a name="l00507"></a>00507         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;listen(2)&quot;</span>);
<a name="l00508"></a>00508 
<a name="l00509"></a>00509     <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(0);
<a name="l00510"></a>00510 }
<a name="l00511"></a>00511 
<a name="l00512"></a>00512 <span class="comment">/*</span>
<a name="l00513"></a>00513 <span class="comment"> * call-seq:</span>
<a name="l00514"></a>00514 <span class="comment"> *      socket.recvfrom(maxlen) =&gt; [mesg, sender_addrinfo]</span>
<a name="l00515"></a>00515 <span class="comment"> *      socket.recvfrom(maxlen, flags) =&gt; [mesg, sender_addrinfo]</span>
<a name="l00516"></a>00516 <span class="comment"> *</span>
<a name="l00517"></a>00517 <span class="comment"> * Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more</span>
<a name="l00518"></a>00518 <span class="comment"> * of the +MSG_+ options. The first element of the results, _mesg_, is the data</span>
<a name="l00519"></a>00519 <span class="comment"> * received. The second element, _sender_addrinfo_, contains protocol-specific</span>
<a name="l00520"></a>00520 <span class="comment"> * address information of the sender.</span>
<a name="l00521"></a>00521 <span class="comment"> *</span>
<a name="l00522"></a>00522 <span class="comment"> * === Parameters</span>
<a name="l00523"></a>00523 <span class="comment"> * * +maxlen+ - the maximum number of bytes to receive from the socket</span>
<a name="l00524"></a>00524 <span class="comment"> * * +flags+ - zero or more of the +MSG_+ options</span>
<a name="l00525"></a>00525 <span class="comment"> *</span>
<a name="l00526"></a>00526 <span class="comment"> * === Example</span>
<a name="l00527"></a>00527 <span class="comment"> *      # In one file, start this first</span>
<a name="l00528"></a>00528 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00529"></a>00529 <span class="comment"> *      include Socket::Constants</span>
<a name="l00530"></a>00530 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00531"></a>00531 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )</span>
<a name="l00532"></a>00532 <span class="comment"> *      socket.bind( sockaddr )</span>
<a name="l00533"></a>00533 <span class="comment"> *      socket.listen( 5 )</span>
<a name="l00534"></a>00534 <span class="comment"> *      client, client_addrinfo = socket.accept</span>
<a name="l00535"></a>00535 <span class="comment"> *      data = client.recvfrom( 20 )[0].chomp</span>
<a name="l00536"></a>00536 <span class="comment"> *      puts &quot;I only received 20 bytes &apos;#{data}&apos;&quot;</span>
<a name="l00537"></a>00537 <span class="comment"> *      sleep 1</span>
<a name="l00538"></a>00538 <span class="comment"> *      socket.close</span>
<a name="l00539"></a>00539 <span class="comment"> *</span>
<a name="l00540"></a>00540 <span class="comment"> *      # In another file, start this second</span>
<a name="l00541"></a>00541 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00542"></a>00542 <span class="comment"> *      include Socket::Constants</span>
<a name="l00543"></a>00543 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00544"></a>00544 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )</span>
<a name="l00545"></a>00545 <span class="comment"> *      socket.connect( sockaddr )</span>
<a name="l00546"></a>00546 <span class="comment"> *      socket.puts &quot;Watch this get cut short!&quot;</span>
<a name="l00547"></a>00547 <span class="comment"> *      socket.close</span>
<a name="l00548"></a>00548 <span class="comment"> *</span>
<a name="l00549"></a>00549 <span class="comment"> * === Unix-based Exceptions</span>
<a name="l00550"></a>00550 <span class="comment"> * On unix-based based systems the following system exceptions may be raised if the</span>
<a name="l00551"></a>00551 <span class="comment"> * call to _recvfrom_ fails:</span>
<a name="l00552"></a>00552 <span class="comment"> * * Errno::EAGAIN - the +socket+ file descriptor is marked as O_NONBLOCK and no</span>
<a name="l00553"></a>00553 <span class="comment"> *   data is waiting to be received; or MSG_OOB is set and no out-of-band data</span>
<a name="l00554"></a>00554 <span class="comment"> *   is available and either the +socket+ file descriptor is marked as</span>
<a name="l00555"></a>00555 <span class="comment"> *   O_NONBLOCK or the +socket+ does not support blocking to wait for</span>
<a name="l00556"></a>00556 <span class="comment"> *   out-of-band-data</span>
<a name="l00557"></a>00557 <span class="comment"> * * Errno::EWOULDBLOCK - see Errno::EAGAIN</span>
<a name="l00558"></a>00558 <span class="comment"> * * Errno::EBADF - the +socket+ is not a valid file descriptor</span>
<a name="l00559"></a>00559 <span class="comment"> * * Errno::ECONNRESET - a connection was forcibly closed by a peer</span>
<a name="l00560"></a>00560 <span class="comment"> * * Errno::EFAULT - the socket&apos;s internal buffer, address or address length</span>
<a name="l00561"></a>00561 <span class="comment"> *   cannot be accessed or written</span>
<a name="l00562"></a>00562 <span class="comment"> * * Errno::EINTR - a signal interrupted _recvfrom_ before any data was available</span>
<a name="l00563"></a>00563 <span class="comment"> * * Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available</span>
<a name="l00564"></a>00564 <span class="comment"> * * Errno::EIO - an i/o error occurred while reading from or writing to the</span>
<a name="l00565"></a>00565 <span class="comment"> *   filesystem</span>
<a name="l00566"></a>00566 <span class="comment"> * * Errno::ENOBUFS - insufficient resources were available in the system to</span>
<a name="l00567"></a>00567 <span class="comment"> *   perform the operation</span>
<a name="l00568"></a>00568 <span class="comment"> * * Errno::ENOMEM - insufficient memory was available to fulfill the request</span>
<a name="l00569"></a>00569 <span class="comment"> * * Errno::ENOSR - there were insufficient STREAMS resources available to</span>
<a name="l00570"></a>00570 <span class="comment"> *   complete the operation</span>
<a name="l00571"></a>00571 <span class="comment"> * * Errno::ENOTCONN - a receive is attempted on a connection-mode socket that</span>
<a name="l00572"></a>00572 <span class="comment"> *   is not connected</span>
<a name="l00573"></a>00573 <span class="comment"> * * Errno::ENOTSOCK - the +socket+ does not refer to a socket</span>
<a name="l00574"></a>00574 <span class="comment"> * * Errno::EOPNOTSUPP - the specified flags are not supported for this socket type</span>
<a name="l00575"></a>00575 <span class="comment"> * * Errno::ETIMEDOUT - the connection timed out during connection establishment</span>
<a name="l00576"></a>00576 <span class="comment"> *   or due to a transmission timeout on an active connection</span>
<a name="l00577"></a>00577 <span class="comment"> *</span>
<a name="l00578"></a>00578 <span class="comment"> * === Windows Exceptions</span>
<a name="l00579"></a>00579 <span class="comment"> * On Windows systems the following system exceptions may be raised if</span>
<a name="l00580"></a>00580 <span class="comment"> * the call to _recvfrom_ fails:</span>
<a name="l00581"></a>00581 <span class="comment"> * * Errno::ENETDOWN - the network is down</span>
<a name="l00582"></a>00582 <span class="comment"> * * Errno::EFAULT - the internal buffer and from parameters on +socket+ are not</span>
<a name="l00583"></a>00583 <span class="comment"> *   part of the user address space, or the internal fromlen parameter is</span>
<a name="l00584"></a>00584 <span class="comment"> *   too small to accommodate the peer address</span>
<a name="l00585"></a>00585 <span class="comment"> * * Errno::EINTR - the (blocking) call was cancelled by an internal call to</span>
<a name="l00586"></a>00586 <span class="comment"> *   the WinSock function WSACancelBlockingCall</span>
<a name="l00587"></a>00587 <span class="comment"> * * Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or</span>
<a name="l00588"></a>00588 <span class="comment"> *   the service provider is still processing a callback function</span>
<a name="l00589"></a>00589 <span class="comment"> * * Errno::EINVAL - +socket+ has not been bound with a call to _bind_, or an</span>
<a name="l00590"></a>00590 <span class="comment"> *   unknown flag was specified, or MSG_OOB was specified for a socket with</span>
<a name="l00591"></a>00591 <span class="comment"> *   SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal</span>
<a name="l00592"></a>00592 <span class="comment"> *   len parameter on +socket+ was zero or negative</span>
<a name="l00593"></a>00593 <span class="comment"> * * Errno::EISCONN - +socket+ is already connected. The call to _recvfrom_ is</span>
<a name="l00594"></a>00594 <span class="comment"> *   not permitted with a connected socket on a socket that is connection</span>
<a name="l00595"></a>00595 <span class="comment"> *   oriented or connectionless.</span>
<a name="l00596"></a>00596 <span class="comment"> * * Errno::ENETRESET - the connection has been broken due to the keep-alive</span>
<a name="l00597"></a>00597 <span class="comment"> *   activity detecting a failure while the operation was in progress.</span>
<a name="l00598"></a>00598 <span class="comment"> * * Errno::EOPNOTSUPP - MSG_OOB was specified, but +socket+ is not stream-style</span>
<a name="l00599"></a>00599 <span class="comment"> *   such as type SOCK_STREAM. OOB data is not supported in the communication</span>
<a name="l00600"></a>00600 <span class="comment"> *   domain associated with +socket+, or +socket+ is unidirectional and</span>
<a name="l00601"></a>00601 <span class="comment"> *   supports only send operations</span>
<a name="l00602"></a>00602 <span class="comment"> * * Errno::ESHUTDOWN - +socket+ has been shutdown. It is not possible to</span>
<a name="l00603"></a>00603 <span class="comment"> *   call _recvfrom_ on a socket after _shutdown_ has been invoked.</span>
<a name="l00604"></a>00604 <span class="comment"> * * Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and a  call to</span>
<a name="l00605"></a>00605 <span class="comment"> *   _recvfrom_ would block.</span>
<a name="l00606"></a>00606 <span class="comment"> * * Errno::EMSGSIZE - the message was too large to fit into the specified buffer</span>
<a name="l00607"></a>00607 <span class="comment"> *   and was truncated.</span>
<a name="l00608"></a>00608 <span class="comment"> * * Errno::ETIMEDOUT - the connection has been dropped, because of a network</span>
<a name="l00609"></a>00609 <span class="comment"> *   failure or because the system on the other end went down without</span>
<a name="l00610"></a>00610 <span class="comment"> *   notice</span>
<a name="l00611"></a>00611 <span class="comment"> * * Errno::ECONNRESET - the virtual circuit was reset by the remote side</span>
<a name="l00612"></a>00612 <span class="comment"> *   executing a hard or abortive close. The application should close the</span>
<a name="l00613"></a>00613 <span class="comment"> *   socket; it is no longer usable. On a UDP-datagram socket this error</span>
<a name="l00614"></a>00614 <span class="comment"> *   indicates a previous send operation resulted in an ICMP Port Unreachable</span>
<a name="l00615"></a>00615 <span class="comment"> *   message.</span>
<a name="l00616"></a>00616 <span class="comment"> */</span>
<a name="l00617"></a>00617 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00618"></a><a class="code" href="../../d5/df8/socket_8c.html#a292a68788435551b78a4c7a80c37b613">00618</a> <a class="code" href="../../d5/df8/socket_8c.html#a292a68788435551b78a4c7a80c37b613">sock_recvfrom</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock)
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620     <span class="keywordflow">return</span> <a class="code" href="../../da/dcc/socket_2init_8c.html#aa9653d7c623087b64b4f1cd808f2590c">rsock_s_recvfrom</a>(sock, argc, argv, <a class="code" href="../../dd/d8c/rubysocket_8h.html#ac5b3661fbf5b7144395ae396056213b5a1fa3f2187a74dcde3e45bfb1e652fd8a">RECV_SOCKET</a>);
<a name="l00621"></a>00621 }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="comment">/*</span>
<a name="l00624"></a>00624 <span class="comment"> * call-seq:</span>
<a name="l00625"></a>00625 <span class="comment"> *      socket.recvfrom_nonblock(maxlen) =&gt; [mesg, sender_addrinfo]</span>
<a name="l00626"></a>00626 <span class="comment"> *      socket.recvfrom_nonblock(maxlen, flags) =&gt; [mesg, sender_addrinfo]</span>
<a name="l00627"></a>00627 <span class="comment"> *</span>
<a name="l00628"></a>00628 <span class="comment"> * Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after</span>
<a name="l00629"></a>00629 <span class="comment"> * O_NONBLOCK is set for the underlying file descriptor.</span>
<a name="l00630"></a>00630 <span class="comment"> * _flags_ is zero or more of the +MSG_+ options.</span>
<a name="l00631"></a>00631 <span class="comment"> * The first element of the results, _mesg_, is the data received.</span>
<a name="l00632"></a>00632 <span class="comment"> * The second element, _sender_addrinfo_, contains protocol-specific address</span>
<a name="l00633"></a>00633 <span class="comment"> * information of the sender.</span>
<a name="l00634"></a>00634 <span class="comment"> *</span>
<a name="l00635"></a>00635 <span class="comment"> * When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns</span>
<a name="l00636"></a>00636 <span class="comment"> * an empty string as data.</span>
<a name="l00637"></a>00637 <span class="comment"> * The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.</span>
<a name="l00638"></a>00638 <span class="comment"> *</span>
<a name="l00639"></a>00639 <span class="comment"> * === Parameters</span>
<a name="l00640"></a>00640 <span class="comment"> * * +maxlen+ - the maximum number of bytes to receive from the socket</span>
<a name="l00641"></a>00641 <span class="comment"> * * +flags+ - zero or more of the +MSG_+ options</span>
<a name="l00642"></a>00642 <span class="comment"> *</span>
<a name="l00643"></a>00643 <span class="comment"> * === Example</span>
<a name="l00644"></a>00644 <span class="comment"> *      # In one file, start this first</span>
<a name="l00645"></a>00645 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00646"></a>00646 <span class="comment"> *      include Socket::Constants</span>
<a name="l00647"></a>00647 <span class="comment"> *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)</span>
<a name="l00648"></a>00648 <span class="comment"> *      sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)</span>
<a name="l00649"></a>00649 <span class="comment"> *      socket.bind(sockaddr)</span>
<a name="l00650"></a>00650 <span class="comment"> *      socket.listen(5)</span>
<a name="l00651"></a>00651 <span class="comment"> *      client, client_addrinfo = socket.accept</span>
<a name="l00652"></a>00652 <span class="comment"> *      begin # emulate blocking recvfrom</span>
<a name="l00653"></a>00653 <span class="comment"> *        pair = client.recvfrom_nonblock(20)</span>
<a name="l00654"></a>00654 <span class="comment"> *      rescue IO::WaitReadable</span>
<a name="l00655"></a>00655 <span class="comment"> *        IO.select([client])</span>
<a name="l00656"></a>00656 <span class="comment"> *        retry</span>
<a name="l00657"></a>00657 <span class="comment"> *      end</span>
<a name="l00658"></a>00658 <span class="comment"> *      data = pair[0].chomp</span>
<a name="l00659"></a>00659 <span class="comment"> *      puts &quot;I only received 20 bytes &apos;#{data}&apos;&quot;</span>
<a name="l00660"></a>00660 <span class="comment"> *      sleep 1</span>
<a name="l00661"></a>00661 <span class="comment"> *      socket.close</span>
<a name="l00662"></a>00662 <span class="comment"> *</span>
<a name="l00663"></a>00663 <span class="comment"> *      # In another file, start this second</span>
<a name="l00664"></a>00664 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00665"></a>00665 <span class="comment"> *      include Socket::Constants</span>
<a name="l00666"></a>00666 <span class="comment"> *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)</span>
<a name="l00667"></a>00667 <span class="comment"> *      sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)</span>
<a name="l00668"></a>00668 <span class="comment"> *      socket.connect(sockaddr)</span>
<a name="l00669"></a>00669 <span class="comment"> *      socket.puts &quot;Watch this get cut short!&quot;</span>
<a name="l00670"></a>00670 <span class="comment"> *      socket.close</span>
<a name="l00671"></a>00671 <span class="comment"> *</span>
<a name="l00672"></a>00672 <span class="comment"> * Refer to Socket#recvfrom for the exceptions that may be thrown if the call</span>
<a name="l00673"></a>00673 <span class="comment"> * to _recvfrom_nonblock_ fails.</span>
<a name="l00674"></a>00674 <span class="comment"> *</span>
<a name="l00675"></a>00675 <span class="comment"> * Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,</span>
<a name="l00676"></a>00676 <span class="comment"> * including Errno::EWOULDBLOCK.</span>
<a name="l00677"></a>00677 <span class="comment"> *</span>
<a name="l00678"></a>00678 <span class="comment"> * If the exception is Errno::EWOULDBLOCK or Errno::AGAIN,</span>
<a name="l00679"></a>00679 <span class="comment"> * it is extended by IO::WaitReadable.</span>
<a name="l00680"></a>00680 <span class="comment"> * So IO::WaitReadable can be used to rescue the exceptions for retrying recvfrom_nonblock.</span>
<a name="l00681"></a>00681 <span class="comment"> *</span>
<a name="l00682"></a>00682 <span class="comment"> * === See</span>
<a name="l00683"></a>00683 <span class="comment"> * * Socket#recvfrom</span>
<a name="l00684"></a>00684 <span class="comment"> */</span>
<a name="l00685"></a>00685 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00686"></a><a class="code" href="../../d5/df8/socket_8c.html#a7995bb0bb548f0a3b9a05094f431647e">00686</a> <a class="code" href="../../d5/df8/socket_8c.html#a7995bb0bb548f0a3b9a05094f431647e">sock_recvfrom_nonblock</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock)
<a name="l00687"></a>00687 {
<a name="l00688"></a>00688     <span class="keywordflow">return</span> <a class="code" href="../../da/dcc/socket_2init_8c.html#a8b56b6d6bb81dd0c8d38944a54b48dd6">rsock_s_recvfrom_nonblock</a>(sock, argc, argv, <a class="code" href="../../dd/d8c/rubysocket_8h.html#ac5b3661fbf5b7144395ae396056213b5a1fa3f2187a74dcde3e45bfb1e652fd8a">RECV_SOCKET</a>);
<a name="l00689"></a>00689 }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691 <span class="comment">/*</span>
<a name="l00692"></a>00692 <span class="comment"> * call-seq:</span>
<a name="l00693"></a>00693 <span class="comment"> *   socket.accept =&gt; [client_socket, client_addrinfo]</span>
<a name="l00694"></a>00694 <span class="comment"> *</span>
<a name="l00695"></a>00695 <span class="comment"> * Accepts a next connection.</span>
<a name="l00696"></a>00696 <span class="comment"> * Returns a new Socket object and Addrinfo object.</span>
<a name="l00697"></a>00697 <span class="comment"> *</span>
<a name="l00698"></a>00698 <span class="comment"> *   serv = Socket.new(:INET, :STREAM, 0)</span>
<a name="l00699"></a>00699 <span class="comment"> *   serv.listen(5)</span>
<a name="l00700"></a>00700 <span class="comment"> *   c = Socket.new(:INET, :STREAM, 0)</span>
<a name="l00701"></a>00701 <span class="comment"> *   c.connect(serv.connect_address)</span>
<a name="l00702"></a>00702 <span class="comment"> *   p serv.accept #=&gt; [#&lt;Socket:fd 6&gt;, #&lt;Addrinfo: 127.0.0.1:48555 TCP&gt;]</span>
<a name="l00703"></a>00703 <span class="comment"> *</span>
<a name="l00704"></a>00704 <span class="comment"> */</span>
<a name="l00705"></a>00705 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00706"></a><a class="code" href="../../d5/df8/socket_8c.html#a44e27a97a613e0a533847d3877d7fd82">00706</a> <a class="code" href="../../d5/df8/socket_8c.html#a44e27a97a613e0a533847d3877d7fd82">sock_accept</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock)
<a name="l00707"></a>00707 {
<a name="l00708"></a>00708     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00709"></a>00709     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock2;
<a name="l00710"></a>00710     <span class="keyword">struct </span><a class="code" href="../../d0/d6d/structsockaddr__storage.html">sockaddr_storage</a> buf;
<a name="l00711"></a>00711     socklen_t <a class="code" href="../../d3/d15/name2ctype_8h.html#aed1cc4dca5d94cb452f79691f54f7423">len</a> = (socklen_t)<span class="keyword">sizeof</span> buf;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00714"></a>00714     sock2 = <a class="code" href="../../da/dcc/socket_2init_8c.html#a891f544fe2db4d667125161a76c3d9b7">rsock_s_accept</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>,fptr-&gt;<a class="code" href="../../dd/d7e/structrb__io__t.html#a0d48f8e91d24ff4f382564b30c1b41c2">fd</a>,(<span class="keyword">struct</span> sockaddr*)&amp;buf,&amp;len);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716     <span class="keywordflow">return</span> <a class="code" href="../../dc/dcc/array_8c.html#af3085ceab406e3f4f4b90f383c440d6a">rb_assoc_new</a>(sock2, <a class="code" href="../../d3/de8/raddrinfo_8c.html#ae511a3d595db6b72dff1ff335fb3c912">rsock_io_socket_addrinfo</a>(sock2, (<span class="keyword">struct</span> sockaddr*)&amp;buf, len));
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="comment">/*</span>
<a name="l00720"></a>00720 <span class="comment"> * call-seq:</span>
<a name="l00721"></a>00721 <span class="comment"> *      socket.accept_nonblock =&gt; [client_socket, client_addrinfo]</span>
<a name="l00722"></a>00722 <span class="comment"> *</span>
<a name="l00723"></a>00723 <span class="comment"> * Accepts an incoming connection using accept(2) after</span>
<a name="l00724"></a>00724 <span class="comment"> * O_NONBLOCK is set for the underlying file descriptor.</span>
<a name="l00725"></a>00725 <span class="comment"> * It returns an array containing the accepted socket</span>
<a name="l00726"></a>00726 <span class="comment"> * for the incoming connection, _client_socket_,</span>
<a name="l00727"></a>00727 <span class="comment"> * and an Addrinfo, _client_addrinfo_.</span>
<a name="l00728"></a>00728 <span class="comment"> *</span>
<a name="l00729"></a>00729 <span class="comment"> * === Example</span>
<a name="l00730"></a>00730 <span class="comment"> *      # In one script, start this first</span>
<a name="l00731"></a>00731 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00732"></a>00732 <span class="comment"> *      include Socket::Constants</span>
<a name="l00733"></a>00733 <span class="comment"> *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)</span>
<a name="l00734"></a>00734 <span class="comment"> *      sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)</span>
<a name="l00735"></a>00735 <span class="comment"> *      socket.bind(sockaddr)</span>
<a name="l00736"></a>00736 <span class="comment"> *      socket.listen(5)</span>
<a name="l00737"></a>00737 <span class="comment"> *      begin # emulate blocking accept</span>
<a name="l00738"></a>00738 <span class="comment"> *        client_socket, client_addrinfo = socket.accept_nonblock</span>
<a name="l00739"></a>00739 <span class="comment"> *      rescue IO::WaitReadable, Errno::EINTR</span>
<a name="l00740"></a>00740 <span class="comment"> *        IO.select([socket])</span>
<a name="l00741"></a>00741 <span class="comment"> *        retry</span>
<a name="l00742"></a>00742 <span class="comment"> *      end</span>
<a name="l00743"></a>00743 <span class="comment"> *      puts &quot;The client said, &apos;#{client_socket.readline.chomp}&apos;&quot;</span>
<a name="l00744"></a>00744 <span class="comment"> *      client_socket.puts &quot;Hello from script one!&quot;</span>
<a name="l00745"></a>00745 <span class="comment"> *      socket.close</span>
<a name="l00746"></a>00746 <span class="comment"> *</span>
<a name="l00747"></a>00747 <span class="comment"> *      # In another script, start this second</span>
<a name="l00748"></a>00748 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00749"></a>00749 <span class="comment"> *      include Socket::Constants</span>
<a name="l00750"></a>00750 <span class="comment"> *      socket = Socket.new(AF_INET, SOCK_STREAM, 0)</span>
<a name="l00751"></a>00751 <span class="comment"> *      sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)</span>
<a name="l00752"></a>00752 <span class="comment"> *      socket.connect(sockaddr)</span>
<a name="l00753"></a>00753 <span class="comment"> *      socket.puts &quot;Hello from script 2.&quot;</span>
<a name="l00754"></a>00754 <span class="comment"> *      puts &quot;The server said, &apos;#{socket.readline.chomp}&apos;&quot;</span>
<a name="l00755"></a>00755 <span class="comment"> *      socket.close</span>
<a name="l00756"></a>00756 <span class="comment"> *</span>
<a name="l00757"></a>00757 <span class="comment"> * Refer to Socket#accept for the exceptions that may be thrown if the call</span>
<a name="l00758"></a>00758 <span class="comment"> * to _accept_nonblock_ fails.</span>
<a name="l00759"></a>00759 <span class="comment"> *</span>
<a name="l00760"></a>00760 <span class="comment"> * Socket#accept_nonblock may raise any error corresponding to accept(2) failure,</span>
<a name="l00761"></a>00761 <span class="comment"> * including Errno::EWOULDBLOCK.</span>
<a name="l00762"></a>00762 <span class="comment"> *</span>
<a name="l00763"></a>00763 <span class="comment"> * If the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED or Errno::EPROTO,</span>
<a name="l00764"></a>00764 <span class="comment"> * it is extended by IO::WaitReadable.</span>
<a name="l00765"></a>00765 <span class="comment"> * So IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock.</span>
<a name="l00766"></a>00766 <span class="comment"> *</span>
<a name="l00767"></a>00767 <span class="comment"> * === See</span>
<a name="l00768"></a>00768 <span class="comment"> * * Socket#accept</span>
<a name="l00769"></a>00769 <span class="comment"> */</span>
<a name="l00770"></a>00770 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00771"></a><a class="code" href="../../d5/df8/socket_8c.html#a5bbe0a5dbdecc04e8d001f3143a57c08">00771</a> <a class="code" href="../../d5/df8/socket_8c.html#a5bbe0a5dbdecc04e8d001f3143a57c08">sock_accept_nonblock</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock)
<a name="l00772"></a>00772 {
<a name="l00773"></a>00773     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00774"></a>00774     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock2;
<a name="l00775"></a>00775     <span class="keyword">struct </span><a class="code" href="../../d0/d6d/structsockaddr__storage.html">sockaddr_storage</a> buf;
<a name="l00776"></a>00776     socklen_t <a class="code" href="../../d3/d15/name2ctype_8h.html#aed1cc4dca5d94cb452f79691f54f7423">len</a> = (socklen_t)<span class="keyword">sizeof</span> buf;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00779"></a>00779     sock2 = <a class="code" href="../../da/dcc/socket_2init_8c.html#a480e9eb18bb8b412d4dddb5fc6a49dc9">rsock_s_accept_nonblock</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, fptr, (<span class="keyword">struct</span> sockaddr *)&amp;buf, &amp;len);
<a name="l00780"></a>00780     <span class="keywordflow">return</span> <a class="code" href="../../dc/dcc/array_8c.html#af3085ceab406e3f4f4b90f383c440d6a">rb_assoc_new</a>(sock2, <a class="code" href="../../d3/de8/raddrinfo_8c.html#ae511a3d595db6b72dff1ff335fb3c912">rsock_io_socket_addrinfo</a>(sock2, (<span class="keyword">struct</span> sockaddr*)&amp;buf, len));
<a name="l00781"></a>00781 }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="comment">/*</span>
<a name="l00784"></a>00784 <span class="comment"> * call-seq:</span>
<a name="l00785"></a>00785 <span class="comment"> *      socket.sysaccept =&gt; [client_socket_fd, client_addrinfo]</span>
<a name="l00786"></a>00786 <span class="comment"> *</span>
<a name="l00787"></a>00787 <span class="comment"> * Accepts an incoming connection returning an array containing the (integer)</span>
<a name="l00788"></a>00788 <span class="comment"> * file descriptor for the incoming connection, _client_socket_fd_,</span>
<a name="l00789"></a>00789 <span class="comment"> * and an Addrinfo, _client_addrinfo_.</span>
<a name="l00790"></a>00790 <span class="comment"> *</span>
<a name="l00791"></a>00791 <span class="comment"> * === Example</span>
<a name="l00792"></a>00792 <span class="comment"> *      # In one script, start this first</span>
<a name="l00793"></a>00793 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00794"></a>00794 <span class="comment"> *      include Socket::Constants</span>
<a name="l00795"></a>00795 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00796"></a>00796 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )</span>
<a name="l00797"></a>00797 <span class="comment"> *      socket.bind( sockaddr )</span>
<a name="l00798"></a>00798 <span class="comment"> *      socket.listen( 5 )</span>
<a name="l00799"></a>00799 <span class="comment"> *      client_fd, client_addrinfo = socket.sysaccept</span>
<a name="l00800"></a>00800 <span class="comment"> *      client_socket = Socket.for_fd( client_fd )</span>
<a name="l00801"></a>00801 <span class="comment"> *      puts &quot;The client said, &apos;#{client_socket.readline.chomp}&apos;&quot;</span>
<a name="l00802"></a>00802 <span class="comment"> *      client_socket.puts &quot;Hello from script one!&quot;</span>
<a name="l00803"></a>00803 <span class="comment"> *      socket.close</span>
<a name="l00804"></a>00804 <span class="comment"> *</span>
<a name="l00805"></a>00805 <span class="comment"> *      # In another script, start this second</span>
<a name="l00806"></a>00806 <span class="comment"> *      require &apos;socket&apos;</span>
<a name="l00807"></a>00807 <span class="comment"> *      include Socket::Constants</span>
<a name="l00808"></a>00808 <span class="comment"> *      socket = Socket.new( AF_INET, SOCK_STREAM, 0 )</span>
<a name="l00809"></a>00809 <span class="comment"> *      sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )</span>
<a name="l00810"></a>00810 <span class="comment"> *      socket.connect( sockaddr )</span>
<a name="l00811"></a>00811 <span class="comment"> *      socket.puts &quot;Hello from script 2.&quot;</span>
<a name="l00812"></a>00812 <span class="comment"> *      puts &quot;The server said, &apos;#{socket.readline.chomp}&apos;&quot;</span>
<a name="l00813"></a>00813 <span class="comment"> *      socket.close</span>
<a name="l00814"></a>00814 <span class="comment"> *</span>
<a name="l00815"></a>00815 <span class="comment"> * Refer to Socket#accept for the exceptions that may be thrown if the call</span>
<a name="l00816"></a>00816 <span class="comment"> * to _sysaccept_ fails.</span>
<a name="l00817"></a>00817 <span class="comment"> *</span>
<a name="l00818"></a>00818 <span class="comment"> * === See</span>
<a name="l00819"></a>00819 <span class="comment"> * * Socket#accept</span>
<a name="l00820"></a>00820 <span class="comment"> */</span>
<a name="l00821"></a>00821 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00822"></a><a class="code" href="../../d5/df8/socket_8c.html#aaf11817ffe09f2f8293510379eebee08">00822</a> <a class="code" href="../../d5/df8/socket_8c.html#aaf11817ffe09f2f8293510379eebee08">sock_sysaccept</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock)
<a name="l00823"></a>00823 {
<a name="l00824"></a>00824     <a class="code" href="../../dd/d7e/structrb__io__t.html">rb_io_t</a> *fptr;
<a name="l00825"></a>00825     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sock2;
<a name="l00826"></a>00826     <span class="keyword">struct </span><a class="code" href="../../d0/d6d/structsockaddr__storage.html">sockaddr_storage</a> buf;
<a name="l00827"></a>00827     socklen_t <a class="code" href="../../d3/d15/name2ctype_8h.html#aed1cc4dca5d94cb452f79691f54f7423">len</a> = (socklen_t)<span class="keyword">sizeof</span> buf;
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <a class="code" href="../../dc/dac/io_8h.html#aa00f0dca97539a5dd0c4e67ad5be93a3">GetOpenFile</a>(sock, fptr);
<a name="l00830"></a>00830     sock2 = <a class="code" href="../../da/dcc/socket_2init_8c.html#a891f544fe2db4d667125161a76c3d9b7">rsock_s_accept</a>(0,fptr-&gt;<a class="code" href="../../dd/d7e/structrb__io__t.html#a0d48f8e91d24ff4f382564b30c1b41c2">fd</a>,(<span class="keyword">struct</span> sockaddr*)&amp;buf,&amp;len);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="keywordflow">return</span> <a class="code" href="../../dc/dcc/array_8c.html#af3085ceab406e3f4f4b90f383c440d6a">rb_assoc_new</a>(sock2, <a class="code" href="../../d3/de8/raddrinfo_8c.html#ae511a3d595db6b72dff1ff335fb3c912">rsock_io_socket_addrinfo</a>(sock2, (<span class="keyword">struct</span> sockaddr*)&amp;buf, len));
<a name="l00833"></a>00833 }
<a name="l00834"></a>00834 
<a name="l00835"></a>00835 <span class="preprocessor">#ifdef HAVE_GETHOSTNAME</span>
<a name="l00836"></a>00836 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00837"></a>00837 <span class="comment"> * call-seq:</span>
<a name="l00838"></a>00838 <span class="comment"> *   Socket.gethostname =&gt; hostname</span>
<a name="l00839"></a>00839 <span class="comment"> *</span>
<a name="l00840"></a>00840 <span class="comment"> * Returns the hostname.</span>
<a name="l00841"></a>00841 <span class="comment"> *</span>
<a name="l00842"></a>00842 <span class="comment"> *   p Socket.gethostname #=&gt; &quot;hal&quot;</span>
<a name="l00843"></a>00843 <span class="comment"> *</span>
<a name="l00844"></a>00844 <span class="comment"> * Note that it is not guaranteed to be able to convert to IP address using gethostbyname, getaddrinfo, etc.</span>
<a name="l00845"></a>00845 <span class="comment"> * If you need local IP address, use Socket.ip_address_list.</span>
<a name="l00846"></a>00846 <span class="comment"> */</span>
<a name="l00847"></a>00847 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00848"></a>00848 <a class="code" href="../../d5/df8/socket_8c.html#a90588fae9887bf7bededce0c899637d3">sock_gethostname</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> obj)
<a name="l00849"></a>00849 {
<a name="l00850"></a>00850 <span class="preprocessor">#ifndef HOST_NAME_MAX</span>
<a name="l00851"></a>00851 <span class="preprocessor"></span><span class="preprocessor">#  define HOST_NAME_MAX 1024</span>
<a name="l00852"></a>00852 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00853"></a>00853 <span class="preprocessor"></span>    <span class="keywordtype">char</span> <a class="code" href="../../d6/da0/nkf-utf8_2nkf_8c.html#ac37f17a60c8b5533aac4840c681f62b8">buf</a>[HOST_NAME_MAX+1];
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a98b91af598acb64fe8497413ce498766">rb_secure</a>(3);
<a name="l00856"></a>00856     <span class="keywordflow">if</span> (gethostname(buf, (<span class="keywordtype">int</span>)<span class="keyword">sizeof</span> buf - 1) &lt; 0)
<a name="l00857"></a>00857         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;gethostname&quot;</span>);
<a name="l00858"></a>00858 
<a name="l00859"></a>00859     buf[<span class="keyword">sizeof</span> buf - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l00860"></a>00860     <span class="keywordflow">return</span> <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(buf);
<a name="l00861"></a>00861 }
<a name="l00862"></a>00862 <span class="preprocessor">#else</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_UNAME</span>
<a name="l00864"></a>00864 <span class="preprocessor"></span>
<a name="l00865"></a>00865 <span class="preprocessor">#include &lt;sys/utsname.h&gt;</span>
<a name="l00866"></a>00866 
<a name="l00867"></a>00867 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00868"></a>00868 <a class="code" href="../../d5/df8/socket_8c.html#a90588fae9887bf7bededce0c899637d3">sock_gethostname</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> obj)
<a name="l00869"></a>00869 {
<a name="l00870"></a>00870     <span class="keyword">struct </span>utsname un;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a98b91af598acb64fe8497413ce498766">rb_secure</a>(3);
<a name="l00873"></a>00873     uname(&amp;un);
<a name="l00874"></a>00874     <span class="keywordflow">return</span> <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(un.nodename);
<a name="l00875"></a>00875 }
<a name="l00876"></a>00876 <span class="preprocessor">#else</span>
<a name="l00877"></a><a class="code" href="../../d5/df8/socket_8c.html#a90588fae9887bf7bededce0c899637d3">00877</a> <span class="preprocessor"></span><span class="preprocessor">#define sock_gethostname rb_f_notimplement</span>
<a name="l00878"></a>00878 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00879"></a>00879 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>
<a name="l00881"></a>00881 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00882"></a><a class="code" href="../../d5/df8/socket_8c.html#af950ea858d293347c3baca6ef6c3d272">00882</a> <a class="code" href="../../d5/df8/socket_8c.html#af950ea858d293347c3baca6ef6c3d272">make_addrinfo</a>(<span class="keyword">struct</span> <a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a> *res0, <span class="keywordtype">int</span> norevlookup)
<a name="l00883"></a>00883 {
<a name="l00884"></a>00884     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> base, ary;
<a name="l00885"></a>00885     <span class="keyword">struct </span><a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a> *res;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     <span class="keywordflow">if</span> (res0 == <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00888"></a>00888         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;host not found&quot;</span>);
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890     base = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l00891"></a>00891     <span class="keywordflow">for</span> (res = res0; res; res = res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#ac8d379469addd7ebbb7cd8f9656268d2">ai_next</a>) {
<a name="l00892"></a>00892         ary = <a class="code" href="../../d3/de8/raddrinfo_8c.html#a065cebec3bb5516327403162bb71caaa">rsock_ipaddr</a>(res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a2a6343a77144ee3079f6e9e0b66c715c">ai_addr</a>, norevlookup);
<a name="l00893"></a>00893         <span class="keywordflow">if</span> (res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a2a824b95c7720aacf8c166b43e912ec3">ai_canonname</a>) {
<a name="l00894"></a>00894             <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(ary)[2] = <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a2a824b95c7720aacf8c166b43e912ec3">ai_canonname</a>);
<a name="l00895"></a>00895         }
<a name="l00896"></a>00896         <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#af8ba790dc4c689a8b38c947924afe3ee">ai_family</a>));
<a name="l00897"></a>00897         <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a2b71233551bb3d551ad76ddd27ced896">ai_socktype</a>));
<a name="l00898"></a>00898         <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a70984f8a57396a9cb6593bc6c030a06c">ai_protocol</a>));
<a name="l00899"></a>00899         <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(base, ary);
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901     <span class="keywordflow">return</span> base;
<a name="l00902"></a>00902 }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00905"></a><a class="code" href="../../d5/df8/socket_8c.html#af179e0e221123f48ea132237496f0121">00905</a> <a class="code" href="../../d5/df8/socket_8c.html#af179e0e221123f48ea132237496f0121">sock_sockaddr</a>(<span class="keyword">struct</span> sockaddr *addr, <span class="keywordtype">size_t</span> <a class="code" href="../../d3/d15/name2ctype_8h.html#aed1cc4dca5d94cb452f79691f54f7423">len</a>)
<a name="l00906"></a>00906 {
<a name="l00907"></a>00907     <span class="keywordtype">char</span> *ptr;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     <span class="keywordflow">switch</span> (addr-&gt;sa_family) {
<a name="l00910"></a>00910       <span class="keywordflow">case</span> AF_INET:
<a name="l00911"></a>00911         ptr = (<span class="keywordtype">char</span>*)&amp;((<span class="keyword">struct</span> sockaddr_in*)addr)-&gt;sin_addr.s_addr;
<a name="l00912"></a>00912         len = <span class="keyword">sizeof</span>(((<span class="keyword">struct</span> sockaddr_in*)addr)-&gt;sin_addr.s_addr);
<a name="l00913"></a>00913         <span class="keywordflow">break</span>;
<a name="l00914"></a>00914 <span class="preprocessor">#ifdef AF_INET6</span>
<a name="l00915"></a>00915 <span class="preprocessor"></span>      <span class="keywordflow">case</span> AF_INET6:
<a name="l00916"></a>00916         ptr = (<span class="keywordtype">char</span>*)&amp;((<span class="keyword">struct</span> sockaddr_in6*)addr)-&gt;sin6_addr.s6_addr;
<a name="l00917"></a>00917         len = <span class="keyword">sizeof</span>(((<span class="keyword">struct</span> sockaddr_in6*)addr)-&gt;sin6_addr.s6_addr);
<a name="l00918"></a>00918         <span class="keywordflow">break</span>;
<a name="l00919"></a>00919 <span class="preprocessor">#endif</span>
<a name="l00920"></a>00920 <span class="preprocessor"></span>      <span class="keywordflow">default</span>:
<a name="l00921"></a>00921         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;unknown socket family:%d&quot;</span>, addr-&gt;sa_family);
<a name="l00922"></a>00922         <span class="keywordflow">break</span>;
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924     <span class="keywordflow">return</span> <a class="code" href="../../db/d2e/intern_8h.html#a48b2b873adb8b6a04254bd631c4b03c5">rb_str_new</a>(ptr, len);
<a name="l00925"></a>00925 }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="comment">/*</span>
<a name="l00928"></a>00928 <span class="comment"> * call-seq:</span>
<a name="l00929"></a>00929 <span class="comment"> *   Socket.gethostbyname(hostname) =&gt; [official_hostname, alias_hostnames, address_family, *address_list]</span>
<a name="l00930"></a>00930 <span class="comment"> *</span>
<a name="l00931"></a>00931 <span class="comment"> * Obtains the host information for _hostname_.</span>
<a name="l00932"></a>00932 <span class="comment"> *</span>
<a name="l00933"></a>00933 <span class="comment"> *   p Socket.gethostbyname(&quot;hal&quot;) #=&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;\x7F\x00\x00\x01&quot;]</span>
<a name="l00934"></a>00934 <span class="comment"> *</span>
<a name="l00935"></a>00935 <span class="comment"> */</span>
<a name="l00936"></a>00936 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00937"></a><a class="code" href="../../d5/df8/socket_8c.html#a74e98327125c7d7cedde4fe8083352e3">00937</a> <a class="code" href="../../d5/df8/socket_8c.html#a74e98327125c7d7cedde4fe8083352e3">sock_s_gethostbyname</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> obj, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> host)
<a name="l00938"></a>00938 {
<a name="l00939"></a>00939     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a98b91af598acb64fe8497413ce498766">rb_secure</a>(3);
<a name="l00940"></a>00940     <span class="keywordflow">return</span> <a class="code" href="../../d3/de8/raddrinfo_8c.html#a0de284a7e24fb693223c754aa7eb13a9">rsock_make_hostent</a>(host, <a class="code" href="../../d3/de8/raddrinfo_8c.html#a10ed0188cfcef5886e9e1706816997e4">rsock_addrinfo</a>(host, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>, SOCK_STREAM, <a class="code" href="../../d5/df7/addrinfo_8h.html#ab2912e6cffeb2353df550f10bbe64cf4">AI_CANONNAME</a>), <a class="code" href="../../d5/df8/socket_8c.html#af179e0e221123f48ea132237496f0121">sock_sockaddr</a>);
<a name="l00941"></a>00941 }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943 <span class="comment">/*</span>
<a name="l00944"></a>00944 <span class="comment"> * call-seq:</span>
<a name="l00945"></a>00945 <span class="comment"> *   Socket.gethostbyaddr(address_string [, address_family]) =&gt; hostent</span>
<a name="l00946"></a>00946 <span class="comment"> *</span>
<a name="l00947"></a>00947 <span class="comment"> * Obtains the host information for _address_.</span>
<a name="l00948"></a>00948 <span class="comment"> *</span>
<a name="l00949"></a>00949 <span class="comment"> *   p Socket.gethostbyaddr([221,186,184,68].pack(&quot;CCCC&quot;))</span>
<a name="l00950"></a>00950 <span class="comment"> *   #=&gt; [&quot;carbon.ruby-lang.org&quot;, [], 2, &quot;\xDD\xBA\xB8D&quot;]</span>
<a name="l00951"></a>00951 <span class="comment"> */</span>
<a name="l00952"></a>00952 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l00953"></a><a class="code" href="../../d5/df8/socket_8c.html#a2cfaf4e1082fd7d24c311d88605eee55">00953</a> <a class="code" href="../../d5/df8/socket_8c.html#a2cfaf4e1082fd7d24c311d88605eee55">sock_s_gethostbyaddr</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv)
<a name="l00954"></a>00954 {
<a name="l00955"></a>00955     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr, family;
<a name="l00956"></a>00956     <span class="keyword">struct </span>hostent *h;
<a name="l00957"></a>00957     <span class="keyword">struct </span>sockaddr *sa;
<a name="l00958"></a>00958     <span class="keywordtype">char</span> **pch;
<a name="l00959"></a>00959     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> ary, <a class="code" href="../../d5/db5/encoding_8c.html#a036ebb5768c1e2811cbd07f872a735de">names</a>;
<a name="l00960"></a>00960     <span class="keywordtype">int</span> t = AF_INET;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;11&quot;</span>, &amp;addr, &amp;family);
<a name="l00963"></a>00963     sa = (<span class="keyword">struct </span>sockaddr*)<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a2665a51abbd5b49c15abff3df00fa9db">StringValuePtr</a>(addr);
<a name="l00964"></a>00964     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(family)) {
<a name="l00965"></a>00965         t = <a class="code" href="../../d4/df3/constants_8c.html#a39ff0a7f7690b7524885e5140b588048">rsock_family_arg</a>(family);
<a name="l00966"></a>00966     }
<a name="l00967"></a>00967 <span class="preprocessor">#ifdef AF_INET6</span>
<a name="l00968"></a>00968 <span class="preprocessor"></span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr) == 16) {
<a name="l00969"></a>00969         t = AF_INET6;
<a name="l00970"></a>00970     }
<a name="l00971"></a>00971 <span class="preprocessor">#endif</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span>    h = gethostbyaddr(<a class="code" href="../../d8/df4/generator_8h.html#aa0c7097c0d82c8372072fbab5a604e39">RSTRING_PTR</a>(addr), <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a5133348f689646af76f8fe8e0af547f5">RSTRING_LENINT</a>(addr), t);
<a name="l00973"></a>00973     <span class="keywordflow">if</span> (h == <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00974"></a>00974 <span class="preprocessor">#ifdef HAVE_HSTRERROR</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>        <span class="keyword">extern</span> <span class="keywordtype">int</span> h_errno;
<a name="l00976"></a>00976         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;%s&quot;</span>, (<span class="keywordtype">char</span>*)hstrerror(h_errno));
<a name="l00977"></a>00977 <span class="preprocessor">#else</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span>        <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;host not found&quot;</span>);
<a name="l00979"></a>00979 <span class="preprocessor">#endif</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span>    }
<a name="l00981"></a>00981     ary = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l00982"></a>00982     <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(h-&gt;h_name));
<a name="l00983"></a>00983     names = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l00984"></a>00984     <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, names);
<a name="l00985"></a>00985     <span class="keywordflow">if</span> (h-&gt;h_aliases != <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>) {
<a name="l00986"></a>00986         <span class="keywordflow">for</span> (pch = h-&gt;h_aliases; *pch; pch++) {
<a name="l00987"></a>00987             <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(names, <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(*pch));
<a name="l00988"></a>00988         }
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990     <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#aca9f83a35416ed9d6e0b860afa5eaf0f">INT2NUM</a>(h-&gt;h_addrtype));
<a name="l00991"></a>00991 <span class="preprocessor">#ifdef h_addr</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (pch = h-&gt;h_addr_list; *pch; pch++) {
<a name="l00993"></a>00993         <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../db/d2e/intern_8h.html#a48b2b873adb8b6a04254bd631c4b03c5">rb_str_new</a>(*pch, h-&gt;h_length));
<a name="l00994"></a>00994     }
<a name="l00995"></a>00995 <span class="preprocessor">#else</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span>    <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(ary, <a class="code" href="../../db/d2e/intern_8h.html#a48b2b873adb8b6a04254bd631c4b03c5">rb_str_new</a>(h-&gt;h_addr, h-&gt;h_length));
<a name="l00997"></a>00997 <span class="preprocessor">#endif</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span>
<a name="l00999"></a>00999     <span class="keywordflow">return</span> ary;
<a name="l01000"></a>01000 }
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 <span class="comment">/*</span>
<a name="l01003"></a>01003 <span class="comment"> * call-seq:</span>
<a name="l01004"></a>01004 <span class="comment"> *   Socket.getservbyname(service_name)                =&gt; port_number</span>
<a name="l01005"></a>01005 <span class="comment"> *   Socket.getservbyname(service_name, protocol_name) =&gt; port_number</span>
<a name="l01006"></a>01006 <span class="comment"> *</span>
<a name="l01007"></a>01007 <span class="comment"> * Obtains the port number for _service_name_.</span>
<a name="l01008"></a>01008 <span class="comment"> *</span>
<a name="l01009"></a>01009 <span class="comment"> * If _protocol_name_ is not given, &quot;tcp&quot; is assumed.</span>
<a name="l01010"></a>01010 <span class="comment"> *</span>
<a name="l01011"></a>01011 <span class="comment"> *   Socket.getservbyname(&quot;smtp&quot;)          #=&gt; 25</span>
<a name="l01012"></a>01012 <span class="comment"> *   Socket.getservbyname(&quot;shell&quot;)         #=&gt; 514</span>
<a name="l01013"></a>01013 <span class="comment"> *   Socket.getservbyname(&quot;syslog&quot;, &quot;udp&quot;) #=&gt; 514</span>
<a name="l01014"></a>01014 <span class="comment"> */</span>
<a name="l01015"></a>01015 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01016"></a><a class="code" href="../../d5/df8/socket_8c.html#a4f788d571ef0509aed6be9ba9d432ee8">01016</a> <a class="code" href="../../d5/df8/socket_8c.html#a4f788d571ef0509aed6be9ba9d432ee8">sock_s_getservbyname</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv)
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> service, <a class="code" href="../../dd/d78/sdbm_8h.html#aacac89d131c6cbb876539c74747c8c50">proto</a>;
<a name="l01019"></a>01019     <span class="keyword">struct </span>servent *sp;
<a name="l01020"></a>01020     <span class="keywordtype">long</span> port;
<a name="l01021"></a>01021     <span class="keyword">const</span> <span class="keywordtype">char</span> *servicename, *protoname = <span class="stringliteral">&quot;tcp&quot;</span>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;11&quot;</span>, &amp;service, &amp;proto);
<a name="l01024"></a>01024     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a0e80f207eb41e9010ec9f0f5f9419fea">StringValue</a>(service);
<a name="l01025"></a>01025     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(proto)) <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a0e80f207eb41e9010ec9f0f5f9419fea">StringValue</a>(proto);
<a name="l01026"></a>01026     servicename = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#afc32c1526ac6cb40ec33cad8782c0bae">StringValueCStr</a>(service);
<a name="l01027"></a>01027     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(proto)) protoname = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#afc32c1526ac6cb40ec33cad8782c0bae">StringValueCStr</a>(proto);
<a name="l01028"></a>01028     sp = getservbyname(servicename, protoname);
<a name="l01029"></a>01029     <span class="keywordflow">if</span> (sp) {
<a name="l01030"></a>01030         port = ntohs(sp-&gt;s_port);
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032     <span class="keywordflow">else</span> {
<a name="l01033"></a>01033         <span class="keywordtype">char</span> *end;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035         port = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a1da69daf7d0b9dfe25ed7bd614bab9c7">STRTOUL</a>(servicename, &amp;end, 0);
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (*end != <span class="charliteral">&apos;\0&apos;</span>) {
<a name="l01037"></a>01037             <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;no such service %s/%s&quot;</span>, servicename, protoname);
<a name="l01038"></a>01038         }
<a name="l01039"></a>01039     }
<a name="l01040"></a>01040     <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#ac55fae7f748afd3fc2533d0d7d06cf5a">INT2FIX</a>(port);
<a name="l01041"></a>01041 }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="comment">/*</span>
<a name="l01044"></a>01044 <span class="comment"> * call-seq:</span>
<a name="l01045"></a>01045 <span class="comment"> *   Socket.getservbyport(port [, protocol_name]) =&gt; service</span>
<a name="l01046"></a>01046 <span class="comment"> *</span>
<a name="l01047"></a>01047 <span class="comment"> * Obtains the port number for _port_.</span>
<a name="l01048"></a>01048 <span class="comment"> *</span>
<a name="l01049"></a>01049 <span class="comment"> * If _protocol_name_ is not given, &quot;tcp&quot; is assumed.</span>
<a name="l01050"></a>01050 <span class="comment"> *</span>
<a name="l01051"></a>01051 <span class="comment"> *   Socket.getservbyport(80)         #=&gt; &quot;www&quot;</span>
<a name="l01052"></a>01052 <span class="comment"> *   Socket.getservbyport(514, &quot;tcp&quot;) #=&gt; &quot;shell&quot;</span>
<a name="l01053"></a>01053 <span class="comment"> *   Socket.getservbyport(514, &quot;udp&quot;) #=&gt; &quot;syslog&quot;</span>
<a name="l01054"></a>01054 <span class="comment"> *</span>
<a name="l01055"></a>01055 <span class="comment"> */</span>
<a name="l01056"></a>01056 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01057"></a><a class="code" href="../../d5/df8/socket_8c.html#a07ee947073d4cf75f43108199b60d656">01057</a> <a class="code" href="../../d5/df8/socket_8c.html#a07ee947073d4cf75f43108199b60d656">sock_s_getservbyport</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv)
<a name="l01058"></a>01058 {
<a name="l01059"></a>01059     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> port, <a class="code" href="../../dd/d78/sdbm_8h.html#aacac89d131c6cbb876539c74747c8c50">proto</a>;
<a name="l01060"></a>01060     <span class="keyword">struct </span>servent *sp;
<a name="l01061"></a>01061     <span class="keywordtype">long</span> portnum;
<a name="l01062"></a>01062     <span class="keyword">const</span> <span class="keywordtype">char</span> *protoname = <span class="stringliteral">&quot;tcp&quot;</span>;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;11&quot;</span>, &amp;port, &amp;proto);
<a name="l01065"></a>01065     portnum = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a93f154f3dcc08027f475bf0c3cc287bd">NUM2LONG</a>(port);
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (portnum != (uint16_t)portnum) {
<a name="l01067"></a>01067         <span class="keyword">const</span> <span class="keywordtype">char</span> *s = portnum &gt; 0 ? <span class="stringliteral">&quot;big&quot;</span> : <span class="stringliteral">&quot;small&quot;</span>;
<a name="l01068"></a>01068         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#a5211161e80760c30e2e009ae0bee7be8">rb_eRangeError</a>, <span class="stringliteral">&quot;integer %ld too %s to convert into `int16_t&apos;&quot;</span>, portnum, s);
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(proto)) protoname = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#afc32c1526ac6cb40ec33cad8782c0bae">StringValueCStr</a>(proto);
<a name="l01071"></a>01071 
<a name="l01072"></a>01072     sp = getservbyport((<span class="keywordtype">int</span>)htons((uint16_t)portnum), protoname);
<a name="l01073"></a>01073     <span class="keywordflow">if</span> (!sp) {
<a name="l01074"></a>01074         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;no such service for port %d/%s&quot;</span>, (<span class="keywordtype">int</span>)portnum, protoname);
<a name="l01075"></a>01075     }
<a name="l01076"></a>01076     <span class="keywordflow">return</span> <a class="code" href="../../db/d2e/intern_8h.html#ad16405ca7b4baa5da742798d500f00e6">rb_tainted_str_new2</a>(sp-&gt;s_name);
<a name="l01077"></a>01077 }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079 <span class="comment">/*</span>
<a name="l01080"></a>01080 <span class="comment"> * call-seq:</span>
<a name="l01081"></a>01081 <span class="comment"> *   Socket.getaddrinfo(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) =&gt; array</span>
<a name="l01082"></a>01082 <span class="comment"> *</span>
<a name="l01083"></a>01083 <span class="comment"> * Obtains address information for _nodename_:_servname_.</span>
<a name="l01084"></a>01084 <span class="comment"> *</span>
<a name="l01085"></a>01085 <span class="comment"> * _family_ should be an address family such as: :INET, :INET6, :UNIX, etc.</span>
<a name="l01086"></a>01086 <span class="comment"> *</span>
<a name="l01087"></a>01087 <span class="comment"> * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.</span>
<a name="l01088"></a>01088 <span class="comment"> *</span>
<a name="l01089"></a>01089 <span class="comment"> * _protocol_ should be a protocol defined in the family.</span>
<a name="l01090"></a>01090 <span class="comment"> * 0 is default protocol for the family.</span>
<a name="l01091"></a>01091 <span class="comment"> *</span>
<a name="l01092"></a>01092 <span class="comment"> * _flags_ should be bitwise OR of Socket::AI_* constants.</span>
<a name="l01093"></a>01093 <span class="comment"> *</span>
<a name="l01094"></a>01094 <span class="comment"> *   Socket.getaddrinfo(&quot;www.ruby-lang.org&quot;, &quot;http&quot;, nil, :STREAM)</span>
<a name="l01095"></a>01095 <span class="comment"> *   #=&gt; [[&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;, 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP</span>
<a name="l01096"></a>01096 <span class="comment"> *</span>
<a name="l01097"></a>01097 <span class="comment"> *   Socket.getaddrinfo(&quot;localhost&quot;, nil)</span>
<a name="l01098"></a>01098 <span class="comment"> *   #=&gt; [[&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP</span>
<a name="l01099"></a>01099 <span class="comment"> *   #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP</span>
<a name="l01100"></a>01100 <span class="comment"> *   #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP</span>
<a name="l01101"></a>01101 <span class="comment"> *</span>
<a name="l01102"></a>01102 <span class="comment"> * _reverse_lookup_ directs the form of the third element, and has to</span>
<a name="l01103"></a>01103 <span class="comment"> * be one of below.</span>
<a name="l01104"></a>01104 <span class="comment"> * If it is ommitted, the default value is +nil+.</span>
<a name="l01105"></a>01105 <span class="comment"> *</span>
<a name="l01106"></a>01106 <span class="comment"> *   +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.</span>
<a name="l01107"></a>01107 <span class="comment"> *   +false+, +:numeric+:  hostname is same as numeric address.</span>
<a name="l01108"></a>01108 <span class="comment"> *   +nil+:              obey to the current +do_not_reverse_lookup+ flag.</span>
<a name="l01109"></a>01109 <span class="comment"> *</span>
<a name="l01110"></a>01110 <span class="comment"> * If Addrinfo object is preferred, use Addrinfo.getaddrinfo.</span>
<a name="l01111"></a>01111 <span class="comment"> */</span>
<a name="l01112"></a>01112 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01113"></a><a class="code" href="../../d5/df8/socket_8c.html#a369470d491264ba274dc3d7af5e2df4b">01113</a> <a class="code" href="../../d5/df8/socket_8c.html#a369470d491264ba274dc3d7af5e2df4b">sock_s_getaddrinfo</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv)
<a name="l01114"></a>01114 {
<a name="l01115"></a>01115     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> host, port, family, socktype, protocol, flags, ret, revlookup;
<a name="l01116"></a>01116     <span class="keyword">struct </span><a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a> hints, *res;
<a name="l01117"></a>01117     <span class="keywordtype">int</span> norevlookup;
<a name="l01118"></a>01118 
<a name="l01119"></a>01119     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;25&quot;</span>, &amp;host, &amp;port, &amp;family, &amp;socktype, &amp;protocol, &amp;flags, &amp;revlookup);
<a name="l01120"></a>01120 
<a name="l01121"></a>01121     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a56d620b94b668ed7665d1616b2c54e48">MEMZERO</a>(&amp;hints, <span class="keyword">struct</span> <a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a>, 1);
<a name="l01122"></a>01122     hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#af8ba790dc4c689a8b38c947924afe3ee">ai_family</a> = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(family) ? <a class="code" href="../../d6/d07/sockport_8h.html#a51dba11ffc8e3b1bf695e721b3144094">PF_UNSPEC</a> : <a class="code" href="../../d4/df3/constants_8c.html#a39ff0a7f7690b7524885e5140b588048">rsock_family_arg</a>(family);
<a name="l01123"></a>01123 
<a name="l01124"></a>01124     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(socktype)) {
<a name="l01125"></a>01125         hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#a2b71233551bb3d551ad76ddd27ced896">ai_socktype</a> = <a class="code" href="../../d4/df3/constants_8c.html#acd5c002b7516bd5262afd6fc4f71151c">rsock_socktype_arg</a>(socktype);
<a name="l01126"></a>01126     }
<a name="l01127"></a>01127     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(protocol)) {
<a name="l01128"></a>01128         hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#a70984f8a57396a9cb6593bc6c030a06c">ai_protocol</a> = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a877c38180d23c5447d976c70dda89d69">NUM2INT</a>(protocol);
<a name="l01129"></a>01129     }
<a name="l01130"></a>01130     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(flags)) {
<a name="l01131"></a>01131         hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#ad0b4d4a9e417a5971162cba19597fcc3">ai_flags</a> = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a877c38180d23c5447d976c70dda89d69">NUM2INT</a>(flags);
<a name="l01132"></a>01132     }
<a name="l01133"></a>01133     <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(revlookup) || !<a class="code" href="../../d6/d28/ipsocket_8c.html#ab9be7bf3be684ce472ff4e7414656ff9">rsock_revlookup_flag</a>(revlookup, &amp;norevlookup)) {
<a name="l01134"></a>01134         norevlookup = <a class="code" href="../../da/dcc/socket_2init_8c.html#aa0eeccbca7911b64b5382e06079afc9a">rsock_do_not_reverse_lookup</a>;
<a name="l01135"></a>01135     }
<a name="l01136"></a>01136     res = <a class="code" href="../../d3/de8/raddrinfo_8c.html#ac7f90f82499925e0b91550750cf018ab">rsock_getaddrinfo</a>(host, port, &amp;hints, 0);
<a name="l01137"></a>01137 
<a name="l01138"></a>01138     ret = <a class="code" href="../../d5/df8/socket_8c.html#af950ea858d293347c3baca6ef6c3d272">make_addrinfo</a>(res, norevlookup);
<a name="l01139"></a>01139     <a class="code" href="../../d5/df7/addrinfo_8h.html#adef9f0657cf2d7402f4a63fc37a2e5e9">freeaddrinfo</a>(res);
<a name="l01140"></a>01140     <span class="keywordflow">return</span> ret;
<a name="l01141"></a>01141 }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 <span class="comment">/*</span>
<a name="l01144"></a>01144 <span class="comment"> * call-seq:</span>
<a name="l01145"></a>01145 <span class="comment"> *   Socket.getnameinfo(sockaddr [, flags]) =&gt; [hostname, servicename]</span>
<a name="l01146"></a>01146 <span class="comment"> *</span>
<a name="l01147"></a>01147 <span class="comment"> * Obtains name information for _sockaddr_.</span>
<a name="l01148"></a>01148 <span class="comment"> *</span>
<a name="l01149"></a>01149 <span class="comment"> * _sockaddr_ should be one of follows.</span>
<a name="l01150"></a>01150 <span class="comment"> * - packed sockaddr string such as Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)</span>
<a name="l01151"></a>01151 <span class="comment"> * - 3-elements array such as [&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;]</span>
<a name="l01152"></a>01152 <span class="comment"> * - 4-elements array such as [&quot;AF_INET&quot;, 80, ignored, &quot;127.0.0.1&quot;]</span>
<a name="l01153"></a>01153 <span class="comment"> *</span>
<a name="l01154"></a>01154 <span class="comment"> * _flags_ should be bitwise OR of Socket::NI_* constants.</span>
<a name="l01155"></a>01155 <span class="comment"> *</span>
<a name="l01156"></a>01156 <span class="comment"> * Note that the last form is compatible with IPSocket#{addr,peeraddr}.</span>
<a name="l01157"></a>01157 <span class="comment"> *</span>
<a name="l01158"></a>01158 <span class="comment"> *   Socket.getnameinfo(Socket.sockaddr_in(80, &quot;127.0.0.1&quot;))       #=&gt; [&quot;localhost&quot;, &quot;www&quot;]</span>
<a name="l01159"></a>01159 <span class="comment"> *   Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;])              #=&gt; [&quot;localhost&quot;, &quot;www&quot;]</span>
<a name="l01160"></a>01160 <span class="comment"> *   Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;localhost&quot;, &quot;127.0.0.1&quot;]) #=&gt; [&quot;localhost&quot;, &quot;www&quot;]</span>
<a name="l01161"></a>01161 <span class="comment"> *</span>
<a name="l01162"></a>01162 <span class="comment"> * If Addrinfo object is preferred, use Addrinfo#getnameinfo.</span>
<a name="l01163"></a>01163 <span class="comment"> */</span>
<a name="l01164"></a>01164 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01165"></a><a class="code" href="../../d5/df8/socket_8c.html#af906a5a77f166216f5ea9e51e4a31358">01165</a> <a class="code" href="../../d5/df8/socket_8c.html#af906a5a77f166216f5ea9e51e4a31358">sock_s_getnameinfo</a>(<span class="keywordtype">int</span> argc, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> *argv)
<a name="l01166"></a>01166 {
<a name="l01167"></a>01167     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> sa, af = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>, host = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>, port = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>, flags, tmp;
<a name="l01168"></a>01168     <span class="keywordtype">char</span> *hptr, *pptr;
<a name="l01169"></a>01169     <span class="keywordtype">char</span> hbuf[1024], pbuf[1024];
<a name="l01170"></a>01170     <span class="keywordtype">int</span> fl;
<a name="l01171"></a>01171     <span class="keyword">struct </span><a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a> hints, *res = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, *r;
<a name="l01172"></a>01172     <span class="keywordtype">int</span> error;
<a name="l01173"></a>01173     <span class="keyword">struct </span><a class="code" href="../../d0/d6d/structsockaddr__storage.html">sockaddr_storage</a> ss;
<a name="l01174"></a>01174     <span class="keyword">struct </span>sockaddr *sap;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176     sa = flags = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>;
<a name="l01177"></a>01177     <a class="code" href="../../d7/d19/group__defmethod.html#gaa7bed88640f01bee619f85fda09d28d7">rb_scan_args</a>(argc, argv, <span class="stringliteral">&quot;11&quot;</span>, &amp;sa, &amp;flags);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     fl = 0;
<a name="l01180"></a>01180     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(flags)) {
<a name="l01181"></a>01181         fl = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a877c38180d23c5447d976c70dda89d69">NUM2INT</a>(flags);
<a name="l01182"></a>01182     }
<a name="l01183"></a>01183     tmp = <a class="code" href="../../d3/de8/raddrinfo_8c.html#abd82b0c7415de4e595f11e57d87c846d">rb_check_sockaddr_string_type</a>(sa);
<a name="l01184"></a>01184     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(tmp)) {
<a name="l01185"></a>01185         sa = tmp;
<a name="l01186"></a>01186         <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(ss) &lt; (<span class="keywordtype">size_t</span>)<a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(sa)) {
<a name="l01187"></a>01187             <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#a565ed9d70f4089e1b4a36e9b3381b8c6">rb_eTypeError</a>, <span class="stringliteral">&quot;sockaddr length too big&quot;</span>);
<a name="l01188"></a>01188         }
<a name="l01189"></a>01189         memcpy(&amp;ss, <a class="code" href="../../d8/df4/generator_8h.html#aa0c7097c0d82c8372072fbab5a604e39">RSTRING_PTR</a>(sa), <a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(sa));
<a name="l01190"></a>01190         <span class="keywordflow">if</span> ((<span class="keywordtype">size_t</span>)<a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(sa) != <a class="code" href="../../d6/d07/sockport_8h.html#a75e8651ca92a74b0c6d2874f7abba70c">SS_LEN</a>(&amp;ss)) {
<a name="l01191"></a>01191             <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#a565ed9d70f4089e1b4a36e9b3381b8c6">rb_eTypeError</a>, <span class="stringliteral">&quot;sockaddr size differs - should not happen&quot;</span>);
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193         sap = (<span class="keyword">struct </span>sockaddr*)&amp;ss;
<a name="l01194"></a>01194         <span class="keywordflow">goto</span> call_nameinfo;
<a name="l01195"></a>01195     }
<a name="l01196"></a>01196     tmp = <a class="code" href="../../dc/dcc/array_8c.html#aaa66361aff757dd7ef869f5b84b3793e">rb_check_array_type</a>(sa);
<a name="l01197"></a>01197     <span class="keywordflow">if</span> (!<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(tmp)) {
<a name="l01198"></a>01198         sa = tmp;
<a name="l01199"></a>01199         <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a56d620b94b668ed7665d1616b2c54e48">MEMZERO</a>(&amp;hints, <span class="keyword">struct</span> <a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a>, 1);
<a name="l01200"></a>01200         <span class="keywordflow">if</span> (<a class="code" href="../../d8/df4/generator_8h.html#ae988773ed219452578f881fc7189c486">RARRAY_LEN</a>(sa) == 3) {
<a name="l01201"></a>01201             af = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[0];
<a name="l01202"></a>01202             port = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[1];
<a name="l01203"></a>01203             host = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[2];
<a name="l01204"></a>01204         }
<a name="l01205"></a>01205         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/df4/generator_8h.html#ae988773ed219452578f881fc7189c486">RARRAY_LEN</a>(sa) &gt;= 4) {
<a name="l01206"></a>01206             af = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[0];
<a name="l01207"></a>01207             port = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[1];
<a name="l01208"></a>01208             host = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[3];
<a name="l01209"></a>01209             <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(host)) {
<a name="l01210"></a>01210                 host = <a class="code" href="../../d8/df4/generator_8h.html#abb794fe2d7c73eea87e7ba2273939a8e">RARRAY_PTR</a>(sa)[2];
<a name="l01211"></a>01211             }
<a name="l01212"></a>01212             <span class="keywordflow">else</span> {
<a name="l01213"></a>01213                 <span class="comment">/*</span>
<a name="l01214"></a>01214 <span class="comment">                 * 4th element holds numeric form, don&apos;t resolve.</span>
<a name="l01215"></a>01215 <span class="comment">                 * see rsock_ipaddr().</span>
<a name="l01216"></a>01216 <span class="comment">                 */</span>
<a name="l01217"></a>01217 <span class="preprocessor">#ifdef AI_NUMERICHOST </span><span class="comment">/* AIX 4.3.3 doesn&apos;t have AI_NUMERICHOST. */</span>
<a name="l01218"></a>01218                 hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#ad0b4d4a9e417a5971162cba19597fcc3">ai_flags</a> |= <a class="code" href="../../d5/df7/addrinfo_8h.html#a2a7070b38894743c536630b2ab25dcef">AI_NUMERICHOST</a>;
<a name="l01219"></a>01219 <span class="preprocessor">#endif</span>
<a name="l01220"></a>01220 <span class="preprocessor"></span>            }
<a name="l01221"></a>01221         }
<a name="l01222"></a>01222         <span class="keywordflow">else</span> {
<a name="l01223"></a>01223             <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;array size should be 3 or 4, %ld given&quot;</span>,
<a name="l01224"></a>01224                      <a class="code" href="../../d8/df4/generator_8h.html#ae988773ed219452578f881fc7189c486">RARRAY_LEN</a>(sa));
<a name="l01225"></a>01225         }
<a name="l01226"></a>01226         <span class="comment">/* host */</span>
<a name="l01227"></a>01227         <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(host)) {
<a name="l01228"></a>01228             hptr = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230         <span class="keywordflow">else</span> {
<a name="l01231"></a>01231             strncpy(hbuf, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a2665a51abbd5b49c15abff3df00fa9db">StringValuePtr</a>(host), <span class="keyword">sizeof</span>(hbuf));
<a name="l01232"></a>01232             hbuf[<span class="keyword">sizeof</span>(hbuf) - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01233"></a>01233             hptr = hbuf;
<a name="l01234"></a>01234         }
<a name="l01235"></a>01235         <span class="comment">/* port */</span>
<a name="l01236"></a>01236         <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(port)) {
<a name="l01237"></a>01237             strcpy(pbuf, <span class="stringliteral">&quot;0&quot;</span>);
<a name="l01238"></a>01238             pptr = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01239"></a>01239         }
<a name="l01240"></a>01240         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../de/de6/ruby_2ruby_8h.html#acf2fcf97dcf9c7c35452730eb3e2aeb2">FIXNUM_P</a>(port)) {
<a name="l01241"></a>01241             <a class="code" href="../../d7/d72/subst_8h.html#aa367b75c5aed883fef5befbdf04835a4">snprintf</a>(pbuf, <span class="keyword">sizeof</span>(pbuf), <span class="stringliteral">&quot;%ld&quot;</span>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a93f154f3dcc08027f475bf0c3cc287bd">NUM2LONG</a>(port));
<a name="l01242"></a>01242             pptr = pbuf;
<a name="l01243"></a>01243         }
<a name="l01244"></a>01244         <span class="keywordflow">else</span> {
<a name="l01245"></a>01245             strncpy(pbuf, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a2665a51abbd5b49c15abff3df00fa9db">StringValuePtr</a>(port), <span class="keyword">sizeof</span>(pbuf));
<a name="l01246"></a>01246             pbuf[<span class="keyword">sizeof</span>(pbuf) - 1] = <span class="charliteral">&apos;\0&apos;</span>;
<a name="l01247"></a>01247             pptr = pbuf;
<a name="l01248"></a>01248         }
<a name="l01249"></a>01249         hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#a2b71233551bb3d551ad76ddd27ced896">ai_socktype</a> = (fl &amp; <a class="code" href="../../d5/df7/addrinfo_8h.html#ac8270b4222f6d9ebf05cba519b48be49">NI_DGRAM</a>) ? SOCK_DGRAM : SOCK_STREAM;
<a name="l01250"></a>01250         <span class="comment">/* af */</span>
<a name="l01251"></a>01251         hints.<a class="code" href="../../d6/d9d/structaddrinfo.html#af8ba790dc4c689a8b38c947924afe3ee">ai_family</a> = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a4832bad8845a35fc50f7a160901854a1">NIL_P</a>(af) ? <a class="code" href="../../d6/d07/sockport_8h.html#a51dba11ffc8e3b1bf695e721b3144094">PF_UNSPEC</a> : <a class="code" href="../../d4/df3/constants_8c.html#a39ff0a7f7690b7524885e5140b588048">rsock_family_arg</a>(af);
<a name="l01252"></a>01252         error = <a class="code" href="../../d3/de8/raddrinfo_8c.html#ab78b9a797c9823e8ce326a01646b2d42">rb_getaddrinfo</a>(hptr, pptr, &amp;hints, &amp;res);
<a name="l01253"></a>01253         <span class="keywordflow">if</span> (error) <span class="keywordflow">goto</span> error_exit_addr;
<a name="l01254"></a>01254         sap = res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a2a6343a77144ee3079f6e9e0b66c715c">ai_addr</a>;
<a name="l01255"></a>01255     }
<a name="l01256"></a>01256     <span class="keywordflow">else</span> {
<a name="l01257"></a>01257         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#a565ed9d70f4089e1b4a36e9b3381b8c6">rb_eTypeError</a>, <span class="stringliteral">&quot;expecting String or Array&quot;</span>);
<a name="l01258"></a>01258     }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260   call_nameinfo:
<a name="l01261"></a>01261     error = <a class="code" href="../../d3/de8/raddrinfo_8c.html#adf36e6cb14d74adfc94858a5ed995c4a">rb_getnameinfo</a>(sap, <a class="code" href="../../d6/d07/sockport_8h.html#a9743484b7a52a962b4a1b9d5af0cd4c9">SA_LEN</a>(sap), hbuf, <span class="keyword">sizeof</span>(hbuf),
<a name="l01262"></a>01262                            pbuf, <span class="keyword">sizeof</span>(pbuf), fl);
<a name="l01263"></a>01263     <span class="keywordflow">if</span> (error) <span class="keywordflow">goto</span> error_exit_name;
<a name="l01264"></a>01264     <span class="keywordflow">if</span> (res) {
<a name="l01265"></a>01265         <span class="keywordflow">for</span> (r = res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#ac8d379469addd7ebbb7cd8f9656268d2">ai_next</a>; r; r = r-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#ac8d379469addd7ebbb7cd8f9656268d2">ai_next</a>) {
<a name="l01266"></a>01266             <span class="keywordtype">char</span> hbuf2[1024], pbuf2[1024];
<a name="l01267"></a>01267 
<a name="l01268"></a>01268             sap = r-&gt;ai_addr;
<a name="l01269"></a>01269             error = <a class="code" href="../../d3/de8/raddrinfo_8c.html#adf36e6cb14d74adfc94858a5ed995c4a">rb_getnameinfo</a>(sap, <a class="code" href="../../d6/d07/sockport_8h.html#a9743484b7a52a962b4a1b9d5af0cd4c9">SA_LEN</a>(sap), hbuf2, <span class="keyword">sizeof</span>(hbuf2),
<a name="l01270"></a>01270                                    pbuf2, <span class="keyword">sizeof</span>(pbuf2), fl);
<a name="l01271"></a>01271             <span class="keywordflow">if</span> (error) <span class="keywordflow">goto</span> error_exit_name;
<a name="l01272"></a>01272             <span class="keywordflow">if</span> (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
<a name="l01273"></a>01273                 <a class="code" href="../../d5/df7/addrinfo_8h.html#adef9f0657cf2d7402f4a63fc37a2e5e9">freeaddrinfo</a>(res);
<a name="l01274"></a>01274                 <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#a3676fcbd54554dca6a332927c85abdac">rb_eSocket</a>, <span class="stringliteral">&quot;sockaddr resolved to multiple nodename&quot;</span>);
<a name="l01275"></a>01275             }
<a name="l01276"></a>01276         }
<a name="l01277"></a>01277         <a class="code" href="../../d5/df7/addrinfo_8h.html#adef9f0657cf2d7402f4a63fc37a2e5e9">freeaddrinfo</a>(res);
<a name="l01278"></a>01278     }
<a name="l01279"></a>01279     <span class="keywordflow">return</span> <a class="code" href="../../dc/dcc/array_8c.html#af3085ceab406e3f4f4b90f383c440d6a">rb_assoc_new</a>(<a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(hbuf), <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(pbuf));
<a name="l01280"></a>01280 
<a name="l01281"></a>01281   error_exit_addr:
<a name="l01282"></a>01282     <span class="keywordflow">if</span> (res) <a class="code" href="../../d5/df7/addrinfo_8h.html#adef9f0657cf2d7402f4a63fc37a2e5e9">freeaddrinfo</a>(res);
<a name="l01283"></a>01283     <a class="code" href="../../da/dcc/socket_2init_8c.html#a07513dfdad98aa0e28c3227ab2148ca7">rsock_raise_socket_error</a>(<span class="stringliteral">&quot;getaddrinfo&quot;</span>, error);
<a name="l01284"></a>01284 
<a name="l01285"></a>01285   error_exit_name:
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (res) <a class="code" href="../../d5/df7/addrinfo_8h.html#adef9f0657cf2d7402f4a63fc37a2e5e9">freeaddrinfo</a>(res);
<a name="l01287"></a>01287     <a class="code" href="../../da/dcc/socket_2init_8c.html#a07513dfdad98aa0e28c3227ab2148ca7">rsock_raise_socket_error</a>(<span class="stringliteral">&quot;getnameinfo&quot;</span>, error);
<a name="l01288"></a>01288 }
<a name="l01289"></a>01289 
<a name="l01290"></a>01290 <span class="comment">/*</span>
<a name="l01291"></a>01291 <span class="comment"> * call-seq:</span>
<a name="l01292"></a>01292 <span class="comment"> *   Socket.sockaddr_in(port, host)      =&gt; sockaddr</span>
<a name="l01293"></a>01293 <span class="comment"> *   Socket.pack_sockaddr_in(port, host) =&gt; sockaddr</span>
<a name="l01294"></a>01294 <span class="comment"> *</span>
<a name="l01295"></a>01295 <span class="comment"> * Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.</span>
<a name="l01296"></a>01296 <span class="comment"> *</span>
<a name="l01297"></a>01297 <span class="comment"> *   Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)</span>
<a name="l01298"></a>01298 <span class="comment"> *   #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>
<a name="l01299"></a>01299 <span class="comment"> *</span>
<a name="l01300"></a>01300 <span class="comment"> *   Socket.sockaddr_in(80, &quot;::1&quot;)</span>
<a name="l01301"></a>01301 <span class="comment"> *   #=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;</span>
<a name="l01302"></a>01302 <span class="comment"> *</span>
<a name="l01303"></a>01303 <span class="comment"> */</span>
<a name="l01304"></a>01304 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01305"></a><a class="code" href="../../d5/df8/socket_8c.html#a0f707cf61887572d6318b4e021123e05">01305</a> <a class="code" href="../../d5/df8/socket_8c.html#a0f707cf61887572d6318b4e021123e05">sock_s_pack_sockaddr_in</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <span class="keyword">self</span>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> port, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> host)
<a name="l01306"></a>01306 {
<a name="l01307"></a>01307     <span class="keyword">struct </span><a class="code" href="../../d6/d9d/structaddrinfo.html">addrinfo</a> *res = <a class="code" href="../../d3/de8/raddrinfo_8c.html#a10ed0188cfcef5886e9e1706816997e4">rsock_addrinfo</a>(host, port, 0, 0);
<a name="l01308"></a>01308     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr = <a class="code" href="../../db/d2e/intern_8h.html#a48b2b873adb8b6a04254bd631c4b03c5">rb_str_new</a>((<span class="keywordtype">char</span>*)res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a2a6343a77144ee3079f6e9e0b66c715c">ai_addr</a>, res-&gt;<a class="code" href="../../d6/d9d/structaddrinfo.html#a225a0fc5785f7956c4444ef799317994">ai_addrlen</a>);
<a name="l01309"></a>01309 
<a name="l01310"></a>01310     <a class="code" href="../../d5/df7/addrinfo_8h.html#adef9f0657cf2d7402f4a63fc37a2e5e9">freeaddrinfo</a>(res);
<a name="l01311"></a>01311     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3bf9ab455a1e0e3e8cfc6ebabd8f12df">OBJ_INFECT</a>(addr, port);
<a name="l01312"></a>01312     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3bf9ab455a1e0e3e8cfc6ebabd8f12df">OBJ_INFECT</a>(addr, host);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     <span class="keywordflow">return</span> addr;
<a name="l01315"></a>01315 }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 <span class="comment">/*</span>
<a name="l01318"></a>01318 <span class="comment"> * call-seq:</span>
<a name="l01319"></a>01319 <span class="comment"> *   Socket.unpack_sockaddr_in(sockaddr) =&gt; [port, ip_address]</span>
<a name="l01320"></a>01320 <span class="comment"> *</span>
<a name="l01321"></a>01321 <span class="comment"> * Unpacks _sockaddr_ into port and ip_address.</span>
<a name="l01322"></a>01322 <span class="comment"> *</span>
<a name="l01323"></a>01323 <span class="comment"> * _sockaddr_ should be a string or an addrinfo for AF_INET/AF_INET6.</span>
<a name="l01324"></a>01324 <span class="comment"> *</span>
<a name="l01325"></a>01325 <span class="comment"> *   sockaddr = Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)</span>
<a name="l01326"></a>01326 <span class="comment"> *   p sockaddr #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>
<a name="l01327"></a>01327 <span class="comment"> *   p Socket.unpack_sockaddr_in(sockaddr) #=&gt; [80, &quot;127.0.0.1&quot;]</span>
<a name="l01328"></a>01328 <span class="comment"> *</span>
<a name="l01329"></a>01329 <span class="comment"> */</span>
<a name="l01330"></a>01330 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01331"></a><a class="code" href="../../d5/df8/socket_8c.html#a3c331cf971119ac51778a5bb4707a447">01331</a> <a class="code" href="../../d5/df8/socket_8c.html#a3c331cf971119ac51778a5bb4707a447">sock_s_unpack_sockaddr_in</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <span class="keyword">self</span>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr)
<a name="l01332"></a>01332 {
<a name="l01333"></a>01333     <span class="keyword">struct </span>sockaddr_in * sockaddr;
<a name="l01334"></a>01334     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> host;
<a name="l01335"></a>01335 
<a name="l01336"></a>01336     sockaddr = (<span class="keyword">struct </span>sockaddr_in*)<a class="code" href="../../dd/d8c/rubysocket_8h.html#a5621cb7963b68efc6d283acee5ca0369">SockAddrStringValuePtr</a>(addr);
<a name="l01337"></a>01337     <span class="keywordflow">if</span> (<a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr) &lt;
<a name="l01338"></a>01338         (<span class="keywordtype">char</span>*)&amp;((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family +
<a name="l01339"></a>01339         <span class="keyword">sizeof</span>(((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family) -
<a name="l01340"></a>01340         (<span class="keywordtype">char</span>*)sockaddr)
<a name="l01341"></a>01341         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;too short sockaddr&quot;</span>);
<a name="l01342"></a>01342     <span class="keywordflow">if</span> (((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family != AF_INET
<a name="l01343"></a>01343 #ifdef INET6
<a name="l01344"></a>01344         &amp;&amp; ((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family != AF_INET6
<a name="l01345"></a>01345 #endif
<a name="l01346"></a>01346         ) {
<a name="l01347"></a>01347 <span class="preprocessor">#ifdef INET6</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>        <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;not an AF_INET/AF_INET6 sockaddr&quot;</span>);
<a name="l01349"></a>01349 <span class="preprocessor">#else</span>
<a name="l01350"></a>01350 <span class="preprocessor"></span>        <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;not an AF_INET sockaddr&quot;</span>);
<a name="l01351"></a>01351 <span class="preprocessor">#endif</span>
<a name="l01352"></a>01352 <span class="preprocessor"></span>    }
<a name="l01353"></a>01353     host = <a class="code" href="../../d3/de8/raddrinfo_8c.html#ad68da1d9bf0f948559150cda9c51b7ca">rsock_make_ipaddr</a>((<span class="keyword">struct</span> sockaddr*)sockaddr);
<a name="l01354"></a>01354     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3bf9ab455a1e0e3e8cfc6ebabd8f12df">OBJ_INFECT</a>(host, addr);
<a name="l01355"></a>01355     <span class="keywordflow">return</span> <a class="code" href="../../dc/dcc/array_8c.html#af3085ceab406e3f4f4b90f383c440d6a">rb_assoc_new</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#aca9f83a35416ed9d6e0b860afa5eaf0f">INT2NUM</a>(ntohs(sockaddr-&gt;sin_port)), host);
<a name="l01356"></a>01356 }
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="preprocessor">#ifdef HAVE_SYS_UN_H</span>
<a name="l01359"></a>01359 <span class="preprocessor"></span>
<a name="l01360"></a>01360 <span class="comment">/*</span>
<a name="l01361"></a>01361 <span class="comment"> * call-seq:</span>
<a name="l01362"></a>01362 <span class="comment"> *   Socket.sockaddr_un(path)      =&gt; sockaddr</span>
<a name="l01363"></a>01363 <span class="comment"> *   Socket.pack_sockaddr_un(path) =&gt; sockaddr</span>
<a name="l01364"></a>01364 <span class="comment"> *</span>
<a name="l01365"></a>01365 <span class="comment"> * Packs _path_ as an AF_UNIX sockaddr string.</span>
<a name="l01366"></a>01366 <span class="comment"> *</span>
<a name="l01367"></a>01367 <span class="comment"> *   Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;</span>
<a name="l01368"></a>01368 <span class="comment"> *</span>
<a name="l01369"></a>01369 <span class="comment"> */</span>
<a name="l01370"></a>01370 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01371"></a>01371 sock_s_pack_sockaddr_un(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <span class="keyword">self</span>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> path)
<a name="l01372"></a>01372 {
<a name="l01373"></a>01373     <span class="keyword">struct </span>sockaddr_un sockaddr;
<a name="l01374"></a>01374     <span class="keywordtype">char</span> *sun_path;
<a name="l01375"></a>01375     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr;
<a name="l01376"></a>01376 
<a name="l01377"></a>01377     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a56d620b94b668ed7665d1616b2c54e48">MEMZERO</a>(&amp;sockaddr, <span class="keyword">struct</span> sockaddr_un, 1);
<a name="l01378"></a>01378     sockaddr.sun_family = AF_UNIX;
<a name="l01379"></a>01379     sun_path = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#afc32c1526ac6cb40ec33cad8782c0bae">StringValueCStr</a>(path);
<a name="l01380"></a>01380     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(sockaddr.sun_path) &lt;= <a class="code" href="../../d6/d7b/strchr_8c.html#a219836f542ce53545052bed5353820ca">strlen</a>(sun_path)) {
<a name="l01381"></a>01381         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;too long unix socket path (max: %dbytes)&quot;</span>,
<a name="l01382"></a>01382             (<span class="keywordtype">int</span>)<span class="keyword">sizeof</span>(sockaddr.sun_path)-1);
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384     strncpy(sockaddr.sun_path, sun_path, <span class="keyword">sizeof</span>(sockaddr.sun_path)-1);
<a name="l01385"></a>01385     addr = <a class="code" href="../../db/d2e/intern_8h.html#a48b2b873adb8b6a04254bd631c4b03c5">rb_str_new</a>((<span class="keywordtype">char</span>*)&amp;sockaddr, <span class="keyword">sizeof</span>(sockaddr));
<a name="l01386"></a>01386     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3bf9ab455a1e0e3e8cfc6ebabd8f12df">OBJ_INFECT</a>(addr, path);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388     <span class="keywordflow">return</span> addr;
<a name="l01389"></a>01389 }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391 <span class="comment">/*</span>
<a name="l01392"></a>01392 <span class="comment"> * call-seq:</span>
<a name="l01393"></a>01393 <span class="comment"> *   Socket.unpack_sockaddr_un(sockaddr) =&gt; path</span>
<a name="l01394"></a>01394 <span class="comment"> *</span>
<a name="l01395"></a>01395 <span class="comment"> * Unpacks _sockaddr_ into path.</span>
<a name="l01396"></a>01396 <span class="comment"> *</span>
<a name="l01397"></a>01397 <span class="comment"> * _sockaddr_ should be a string or an addrinfo for AF_UNIX.</span>
<a name="l01398"></a>01398 <span class="comment"> *</span>
<a name="l01399"></a>01399 <span class="comment"> *   sockaddr = Socket.sockaddr_un(&quot;/tmp/sock&quot;)</span>
<a name="l01400"></a>01400 <span class="comment"> *   p Socket.unpack_sockaddr_un(sockaddr) #=&gt; &quot;/tmp/sock&quot;</span>
<a name="l01401"></a>01401 <span class="comment"> *</span>
<a name="l01402"></a>01402 <span class="comment"> */</span>
<a name="l01403"></a>01403 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01404"></a>01404 sock_s_unpack_sockaddr_un(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <span class="keyword">self</span>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> addr)
<a name="l01405"></a>01405 {
<a name="l01406"></a>01406     <span class="keyword">struct </span>sockaddr_un * sockaddr;
<a name="l01407"></a>01407     <span class="keyword">const</span> <span class="keywordtype">char</span> *sun_path;
<a name="l01408"></a>01408     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> path;
<a name="l01409"></a>01409 
<a name="l01410"></a>01410     sockaddr = (<span class="keyword">struct </span>sockaddr_un*)<a class="code" href="../../dd/d8c/rubysocket_8h.html#a5621cb7963b68efc6d283acee5ca0369">SockAddrStringValuePtr</a>(addr);
<a name="l01411"></a>01411     <span class="keywordflow">if</span> (<a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr) &lt;
<a name="l01412"></a>01412         (<span class="keywordtype">char</span>*)&amp;((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family +
<a name="l01413"></a>01413         <span class="keyword">sizeof</span>(((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family) -
<a name="l01414"></a>01414         (<span class="keywordtype">char</span>*)sockaddr)
<a name="l01415"></a>01415         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;too short sockaddr&quot;</span>);
<a name="l01416"></a>01416     <span class="keywordflow">if</span> (((<span class="keyword">struct</span> sockaddr *)sockaddr)-&gt;sa_family != AF_UNIX) {
<a name="l01417"></a>01417         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;not an AF_UNIX sockaddr&quot;</span>);
<a name="l01418"></a>01418     }
<a name="l01419"></a>01419     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un) &lt; (<span class="keywordtype">size_t</span>)<a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr)) {
<a name="l01420"></a>01420         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#a565ed9d70f4089e1b4a36e9b3381b8c6">rb_eTypeError</a>, <span class="stringliteral">&quot;too long sockaddr_un - %ld longer than %d&quot;</span>,
<a name="l01421"></a>01421                  <a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr), (<span class="keywordtype">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));
<a name="l01422"></a>01422     }
<a name="l01423"></a>01423     sun_path = rsock_unixpath(sockaddr, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a5133348f689646af76f8fe8e0af547f5">RSTRING_LENINT</a>(addr));
<a name="l01424"></a>01424     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un) == <a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr) &amp;&amp;
<a name="l01425"></a>01425         sun_path == sockaddr-&gt;sun_path &amp;&amp;
<a name="l01426"></a>01426         sun_path + <a class="code" href="../../d6/d7b/strchr_8c.html#a219836f542ce53545052bed5353820ca">strlen</a>(sun_path) == <a class="code" href="../../d8/df4/generator_8h.html#aa0c7097c0d82c8372072fbab5a604e39">RSTRING_PTR</a>(addr) + <a class="code" href="../../d8/df4/generator_8h.html#a1661e63c26c5cbeef7217d05b0f33942">RSTRING_LEN</a>(addr)) {
<a name="l01427"></a>01427         <a class="code" href="../../db/dcc/error_8c.html#a0f771a2840561f1838169b3d7d4616f3">rb_raise</a>(<a class="code" href="../../db/dcc/error_8c.html#ab5e2a9fec766c75176fbb262bfe6a596">rb_eArgError</a>, <span class="stringliteral">&quot;sockaddr_un.sun_path not NUL terminated&quot;</span>);
<a name="l01428"></a>01428     }
<a name="l01429"></a>01429     path = <a class="code" href="../../db/d2e/intern_8h.html#a03acd62c0b1edebbe1d61f957c19b7ac">rb_str_new2</a>(sun_path);
<a name="l01430"></a>01430     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3bf9ab455a1e0e3e8cfc6ebabd8f12df">OBJ_INFECT</a>(path, addr);
<a name="l01431"></a>01431     <span class="keywordflow">return</span> path;
<a name="l01432"></a>01432 }
<a name="l01433"></a>01433 <span class="preprocessor">#endif</span>
<a name="l01434"></a>01434 <span class="preprocessor"></span>
<a name="l01435"></a>01435 <span class="preprocessor">#if defined(HAVE_GETIFADDRS) || defined(SIOCGLIFCONF) || defined(SIOCGIFCONF) || defined(_WIN32)</span>
<a name="l01436"></a>01436 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01437"></a>01437 sockaddr_obj(<span class="keyword">struct</span> sockaddr *addr)
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439     socklen_t <a class="code" href="../../d3/d15/name2ctype_8h.html#aed1cc4dca5d94cb452f79691f54f7423">len</a>;
<a name="l01440"></a>01440 <span class="preprocessor">#if defined(AF_INET6) &amp;&amp; defined(__KAME__)</span>
<a name="l01441"></a>01441 <span class="preprocessor"></span>    <span class="keyword">struct </span>sockaddr_in6 addr6;
<a name="l01442"></a>01442 <span class="preprocessor">#endif</span>
<a name="l01443"></a>01443 <span class="preprocessor"></span>
<a name="l01444"></a>01444     <span class="keywordflow">if</span> (addr == NULL)
<a name="l01445"></a>01445         <span class="keywordflow">return</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447     <span class="keywordflow">switch</span> (addr-&gt;sa_family) {
<a name="l01448"></a>01448       <span class="keywordflow">case</span> AF_INET:
<a name="l01449"></a>01449         len = (socklen_t)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);
<a name="l01450"></a>01450         <span class="keywordflow">break</span>;
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="preprocessor">#ifdef AF_INET6</span>
<a name="l01453"></a>01453 <span class="preprocessor"></span>      <span class="keywordflow">case</span> AF_INET6:
<a name="l01454"></a>01454         len = (socklen_t)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6);
<a name="l01455"></a>01455 <span class="preprocessor">#  ifdef __KAME__</span>
<a name="l01456"></a>01456 <span class="preprocessor"></span>        <span class="comment">/* KAME uses the 2nd 16bit word of link local IPv6 address as interface index internally */</span>
<a name="l01457"></a>01457         <span class="comment">/* http://orange.kame.net/dev/cvsweb.cgi/kame/IMPLEMENTATION */</span>
<a name="l01458"></a>01458         <span class="comment">/* convert fe80:1::1 to fe80::1%1 */</span>
<a name="l01459"></a>01459         memcpy(&amp;addr6, addr, len);
<a name="l01460"></a>01460         addr = (<span class="keyword">struct </span>sockaddr *)&amp;addr6;
<a name="l01461"></a>01461         <span class="keywordflow">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;addr6.sin6_addr) &amp;&amp;
<a name="l01462"></a>01462             addr6.sin6_scope_id == 0 &amp;&amp;
<a name="l01463"></a>01463             (addr6.sin6_addr.s6_addr[2] || addr6.sin6_addr.s6_addr[3])) {
<a name="l01464"></a>01464             addr6.sin6_scope_id = (addr6.sin6_addr.s6_addr[2] &lt;&lt; 8) | addr6.sin6_addr.s6_addr[3];
<a name="l01465"></a>01465             addr6.sin6_addr.s6_addr[2] = 0;
<a name="l01466"></a>01466             addr6.sin6_addr.s6_addr[3] = 0;
<a name="l01467"></a>01467         }
<a name="l01468"></a>01468 <span class="preprocessor">#  endif</span>
<a name="l01469"></a>01469 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l01470"></a>01470 <span class="preprocessor">#endif</span>
<a name="l01471"></a>01471 <span class="preprocessor"></span>
<a name="l01472"></a>01472 <span class="preprocessor">#ifdef HAVE_SYS_UN_H</span>
<a name="l01473"></a>01473 <span class="preprocessor"></span>      <span class="keywordflow">case</span> AF_UNIX:
<a name="l01474"></a>01474         len = (socklen_t)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un);
<a name="l01475"></a>01475         <span class="keywordflow">break</span>;
<a name="l01476"></a>01476 <span class="preprocessor">#endif</span>
<a name="l01477"></a>01477 <span class="preprocessor"></span>
<a name="l01478"></a>01478       <span class="keywordflow">default</span>:
<a name="l01479"></a>01479         len = (socklen_t)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);
<a name="l01480"></a>01480         <span class="keywordflow">break</span>;
<a name="l01481"></a>01481     }
<a name="l01482"></a>01482 <span class="preprocessor">#ifdef SA_LEN</span>
<a name="l01483"></a>01483 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (len &lt; (socklen_t)<a class="code" href="../../d6/d07/sockport_8h.html#a9743484b7a52a962b4a1b9d5af0cd4c9">SA_LEN</a>(addr))
<a name="l01484"></a>01484         len = (socklen_t)<a class="code" href="../../d6/d07/sockport_8h.html#a9743484b7a52a962b4a1b9d5af0cd4c9">SA_LEN</a>(addr);
<a name="l01485"></a>01485 <span class="preprocessor">#endif</span>
<a name="l01486"></a>01486 <span class="preprocessor"></span>
<a name="l01487"></a>01487     <span class="keywordflow">return</span> <a class="code" href="../../d3/de8/raddrinfo_8c.html#a0b5edb1913114516540924cb1bd73ef5">rsock_addrinfo_new</a>(addr, len, addr-&gt;sa_family, 0, 0, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>, <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>);
<a name="l01488"></a>01488 }
<a name="l01489"></a>01489 <span class="preprocessor">#endif</span>
<a name="l01490"></a>01490 <span class="preprocessor"></span>
<a name="l01491"></a>01491 <span class="preprocessor">#if defined(HAVE_GETIFADDRS) || (defined(SIOCGLIFCONF) &amp;&amp; defined(SIOCGLIFNUM) &amp;&amp; !defined(__hpux)) || defined(SIOCGIFCONF) ||  defined(_WIN32)</span>
<a name="l01492"></a>01492 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01493"></a>01493 <span class="comment"> * call-seq:</span>
<a name="l01494"></a>01494 <span class="comment"> *   Socket.ip_address_list =&gt; array</span>
<a name="l01495"></a>01495 <span class="comment"> *</span>
<a name="l01496"></a>01496 <span class="comment"> * Returns local IP addresses as an array.</span>
<a name="l01497"></a>01497 <span class="comment"> *</span>
<a name="l01498"></a>01498 <span class="comment"> * The array contains Addrinfo objects.</span>
<a name="l01499"></a>01499 <span class="comment"> *</span>
<a name="l01500"></a>01500 <span class="comment"> *  pp Socket.ip_address_list</span>
<a name="l01501"></a>01501 <span class="comment"> *  #=&gt; [#&lt;Addrinfo: 127.0.0.1&gt;,</span>
<a name="l01502"></a>01502 <span class="comment"> *       #&lt;Addrinfo: 192.168.0.128&gt;,</span>
<a name="l01503"></a>01503 <span class="comment"> *       #&lt;Addrinfo: ::1&gt;,</span>
<a name="l01504"></a>01504 <span class="comment"> *       ...]</span>
<a name="l01505"></a>01505 <span class="comment"> *</span>
<a name="l01506"></a>01506 <span class="comment"> */</span>
<a name="l01507"></a>01507 <span class="keyword">static</span> <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a>
<a name="l01508"></a>01508 <a class="code" href="../../d5/df8/socket_8c.html#a645a96b8437b293856018e78049ccfb4">socket_s_ip_address_list</a>(<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <span class="keyword">self</span>)
<a name="l01509"></a>01509 {
<a name="l01510"></a>01510 <span class="preprocessor">#if defined(HAVE_GETIFADDRS)</span>
<a name="l01511"></a>01511 <span class="preprocessor"></span>    <span class="keyword">struct </span>ifaddrs *ifp = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01512"></a>01512     <span class="keyword">struct </span>ifaddrs *p;
<a name="l01513"></a>01513     <span class="keywordtype">int</span> ret;
<a name="l01514"></a>01514     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> <a class="code" href="../../d5/db5/encoding_8c.html#a05f70dacbe595d27364e1e014efb0c8e">list</a>;
<a name="l01515"></a>01515 
<a name="l01516"></a>01516     ret = getifaddrs(&amp;ifp);
<a name="l01517"></a>01517     <span class="keywordflow">if</span> (ret == -1) {
<a name="l01518"></a>01518         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;getifaddrs&quot;</span>);
<a name="l01519"></a>01519     }
<a name="l01520"></a>01520 
<a name="l01521"></a>01521     list = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l01522"></a>01522     <span class="keywordflow">for</span> (p = ifp; p; p = p-&gt;ifa_next) {
<a name="l01523"></a>01523         <span class="keywordflow">if</span> (p-&gt;ifa_addr != NULL &amp;&amp; <a class="code" href="../../dd/d8c/rubysocket_8h.html#a04da22756ad61ba67ddc856d5e0ebb40">IS_IP_FAMILY</a>(p-&gt;ifa_addr-&gt;sa_family)) {
<a name="l01524"></a>01524             <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(list, sockaddr_obj(p-&gt;ifa_addr));
<a name="l01525"></a>01525         }
<a name="l01526"></a>01526     }
<a name="l01527"></a>01527 
<a name="l01528"></a>01528     freeifaddrs(ifp);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     <span class="keywordflow">return</span> list;
<a name="l01531"></a>01531 <span class="preprocessor">#elif defined(SIOCGLIFCONF) &amp;&amp; defined(SIOCGLIFNUM) &amp;&amp; !defined(__hpux)</span>
<a name="l01532"></a>01532 <span class="preprocessor"></span>    <span class="comment">/* Solaris if_tcp(7P) */</span>
<a name="l01533"></a>01533     <span class="comment">/* HP-UX has SIOCGLIFCONF too.  But it uses different struct */</span>
<a name="l01534"></a>01534     <span class="keywordtype">int</span> fd = -1;
<a name="l01535"></a>01535     <span class="keywordtype">int</span> ret;
<a name="l01536"></a>01536     <span class="keyword">struct </span>lifnum ln;
<a name="l01537"></a>01537     <span class="keyword">struct </span>lifconf lc;
<a name="l01538"></a>01538     <span class="keywordtype">char</span> *reason = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01539"></a>01539     <span class="keywordtype">int</span> save_errno;
<a name="l01540"></a>01540     <span class="keywordtype">int</span> i;
<a name="l01541"></a>01541     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> list = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>;
<a name="l01542"></a>01542 
<a name="l01543"></a>01543     lc.lifc_buf = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545     fd = socket(AF_INET, SOCK_DGRAM, 0);
<a name="l01546"></a>01546     <span class="keywordflow">if</span> (fd == -1)
<a name="l01547"></a>01547         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;socket&quot;</span>);
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     memset(&amp;ln, 0, <span class="keyword">sizeof</span>(ln));
<a name="l01550"></a>01550     ln.lifn_family = <a class="code" href="../../d6/d07/sockport_8h.html#ae77ae24b14b7b7f294f3e04121173f12">AF_UNSPEC</a>;
<a name="l01551"></a>01551 
<a name="l01552"></a>01552     ret = <a class="code" href="../../dc/db1/win32_8h.html#ae3a230c65883ec8edc50e3a09ca80003">ioctl</a>(fd, SIOCGLIFNUM, &amp;ln);
<a name="l01553"></a>01553     <span class="keywordflow">if</span> (ret == -1) {
<a name="l01554"></a>01554         reason = <span class="stringliteral">&quot;SIOCGLIFNUM&quot;</span>;
<a name="l01555"></a>01555         <span class="keywordflow">goto</span> finish;
<a name="l01556"></a>01556     }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558     memset(&amp;lc, 0, <span class="keyword">sizeof</span>(lc));
<a name="l01559"></a>01559     lc.lifc_family = <a class="code" href="../../d6/d07/sockport_8h.html#ae77ae24b14b7b7f294f3e04121173f12">AF_UNSPEC</a>;
<a name="l01560"></a>01560     lc.lifc_flags = 0;
<a name="l01561"></a>01561     lc.lifc_len = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>lifreq) * ln.lifn_count;
<a name="l01562"></a>01562     lc.lifc_req = <a class="code" href="../../d8/db0/defines_8h.html#a6af5faec3f9662b20ffc9903f923dec0">xmalloc</a>(lc.lifc_len);
<a name="l01563"></a>01563 
<a name="l01564"></a>01564     ret = <a class="code" href="../../dc/db1/win32_8h.html#ae3a230c65883ec8edc50e3a09ca80003">ioctl</a>(fd, SIOCGLIFCONF, &amp;lc);
<a name="l01565"></a>01565     <span class="keywordflow">if</span> (ret == -1) {
<a name="l01566"></a>01566         reason = <span class="stringliteral">&quot;SIOCGLIFCONF&quot;</span>;
<a name="l01567"></a>01567         <span class="keywordflow">goto</span> finish;
<a name="l01568"></a>01568     }
<a name="l01569"></a>01569 
<a name="l01570"></a>01570     list = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l01571"></a>01571     <span class="keywordflow">for</span> (i = 0; i &lt; ln.lifn_count; i++) {
<a name="l01572"></a>01572         <span class="keyword">struct </span>lifreq *req = &amp;lc.lifc_req[i];
<a name="l01573"></a>01573         <span class="keywordflow">if</span> (<a class="code" href="../../dd/d8c/rubysocket_8h.html#a04da22756ad61ba67ddc856d5e0ebb40">IS_IP_FAMILY</a>(req-&gt;lifr_addr.ss_family)) {
<a name="l01574"></a>01574             <span class="keywordflow">if</span> (req-&gt;lifr_addr.ss_family == AF_INET6 &amp;&amp;
<a name="l01575"></a>01575                 IN6_IS_ADDR_LINKLOCAL(&amp;((<span class="keyword">struct</span> sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_addr) &amp;&amp;
<a name="l01576"></a>01576                 ((<span class="keyword">struct</span> sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_scope_id == 0) {
<a name="l01577"></a>01577                 <span class="keyword">struct </span>lifreq req2;
<a name="l01578"></a>01578                 memcpy(req2.lifr_name, req-&gt;lifr_name, LIFNAMSIZ);
<a name="l01579"></a>01579                 ret = <a class="code" href="../../dc/db1/win32_8h.html#ae3a230c65883ec8edc50e3a09ca80003">ioctl</a>(fd, SIOCGLIFINDEX, &amp;req2);
<a name="l01580"></a>01580                 <span class="keywordflow">if</span> (ret == -1) {
<a name="l01581"></a>01581                     reason = <span class="stringliteral">&quot;SIOCGLIFINDEX&quot;</span>;
<a name="l01582"></a>01582                     <span class="keywordflow">goto</span> finish;
<a name="l01583"></a>01583                 }
<a name="l01584"></a>01584                 ((<span class="keyword">struct </span>sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_scope_id = req2.lifr_index;
<a name="l01585"></a>01585             }
<a name="l01586"></a>01586             <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(list, sockaddr_obj((<span class="keyword">struct</span> sockaddr *)&amp;req-&gt;lifr_addr));
<a name="l01587"></a>01587         }
<a name="l01588"></a>01588     }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590   finish:
<a name="l01591"></a>01591     save_errno = <a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a>;
<a name="l01592"></a>01592     <span class="keywordflow">if</span> (lc.lifc_buf != NULL)
<a name="l01593"></a>01593         <a class="code" href="../../d8/db0/defines_8h.html#a2c3897f7c46ca54a2e0dd7b24a40c7cb">xfree</a>(lc.lifc_req);
<a name="l01594"></a>01594     <span class="keywordflow">if</span> (fd != -1)
<a name="l01595"></a>01595         close(fd);
<a name="l01596"></a>01596     <a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a> = save_errno;
<a name="l01597"></a>01597 
<a name="l01598"></a>01598     <span class="keywordflow">if</span> (reason)
<a name="l01599"></a>01599         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(reason);
<a name="l01600"></a>01600     <span class="keywordflow">return</span> list;
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 <span class="preprocessor">#elif defined(SIOCGIFCONF)</span>
<a name="l01603"></a>01603 <span class="preprocessor"></span>    <span class="keywordtype">int</span> fd = -1;
<a name="l01604"></a>01604     <span class="keywordtype">int</span> ret;
<a name="l01605"></a>01605 <span class="preprocessor">#define EXTRA_SPACE (sizeof(struct ifconf) + sizeof(struct sockaddr_storage))</span>
<a name="l01606"></a>01606 <span class="preprocessor"></span>    <span class="keywordtype">char</span> initbuf[4096+EXTRA_SPACE];
<a name="l01607"></a>01607     <span class="keywordtype">char</span> *buf = initbuf;
<a name="l01608"></a>01608     <span class="keywordtype">int</span> bufsize;
<a name="l01609"></a>01609     <span class="keyword">struct </span>ifconf conf;
<a name="l01610"></a>01610     <span class="keyword">struct </span>ifreq *req;
<a name="l01611"></a>01611     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> list = <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a320970f989dc8294c8203154e3db40c1">Qnil</a>;
<a name="l01612"></a>01612     <span class="keyword">const</span> <span class="keywordtype">char</span> *reason = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01613"></a>01613     <span class="keywordtype">int</span> save_errno;
<a name="l01614"></a>01614 
<a name="l01615"></a>01615     fd = socket(AF_INET, SOCK_DGRAM, 0);
<a name="l01616"></a>01616     <span class="keywordflow">if</span> (fd == -1)
<a name="l01617"></a>01617         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;socket&quot;</span>);
<a name="l01618"></a>01618 
<a name="l01619"></a>01619     bufsize = <span class="keyword">sizeof</span>(initbuf);
<a name="l01620"></a>01620     buf = initbuf;
<a name="l01621"></a>01621 
<a name="l01622"></a>01622   retry:
<a name="l01623"></a>01623     conf.ifc_len = bufsize;
<a name="l01624"></a>01624     conf.ifc_req = (<span class="keyword">struct </span>ifreq *)buf;
<a name="l01625"></a>01625 
<a name="l01626"></a>01626     <span class="comment">/* fprintf(stderr, &quot;bufsize: %d\n&quot;, bufsize); */</span>
<a name="l01627"></a>01627 
<a name="l01628"></a>01628     ret = <a class="code" href="../../dc/db1/win32_8h.html#ae3a230c65883ec8edc50e3a09ca80003">ioctl</a>(fd, SIOCGIFCONF, &amp;conf);
<a name="l01629"></a>01629     <span class="keywordflow">if</span> (ret == -1) {
<a name="l01630"></a>01630         reason = <span class="stringliteral">&quot;SIOCGIFCONF&quot;</span>;
<a name="l01631"></a>01631         <span class="keywordflow">goto</span> finish;
<a name="l01632"></a>01632     }
<a name="l01633"></a>01633 
<a name="l01634"></a>01634     <span class="comment">/* fprintf(stderr, &quot;conf.ifc_len: %d\n&quot;, conf.ifc_len); */</span>
<a name="l01635"></a>01635 
<a name="l01636"></a>01636     <span class="keywordflow">if</span> (bufsize - EXTRA_SPACE &lt; conf.ifc_len) {
<a name="l01637"></a>01637         <span class="keywordflow">if</span> (bufsize &lt; conf.ifc_len) {
<a name="l01638"></a>01638             <span class="comment">/* NetBSD returns required size for all interfaces. */</span>
<a name="l01639"></a>01639             bufsize = conf.ifc_len + EXTRA_SPACE;
<a name="l01640"></a>01640         }
<a name="l01641"></a>01641         <span class="keywordflow">else</span> {
<a name="l01642"></a>01642             bufsize = bufsize &lt;&lt; 1;
<a name="l01643"></a>01643         }
<a name="l01644"></a>01644         <span class="keywordflow">if</span> (buf == initbuf)
<a name="l01645"></a>01645             buf = <a class="code" href="../../d3/d09/ripper_8y.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;
<a name="l01646"></a>01646         buf = <a class="code" href="../../d8/db0/defines_8h.html#a40740062faf2d95d4935112447c464ef">xrealloc</a>(buf, bufsize);
<a name="l01647"></a>01647         <span class="keywordflow">goto</span> retry;
<a name="l01648"></a>01648     }
<a name="l01649"></a>01649 
<a name="l01650"></a>01650     close(fd);
<a name="l01651"></a>01651     fd = -1;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653     list = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l01654"></a>01654     req = conf.ifc_req;
<a name="l01655"></a>01655     <span class="keywordflow">while</span> ((<span class="keywordtype">char</span>*)req &lt; (<span class="keywordtype">char</span>*)conf.ifc_req + conf.ifc_len) {
<a name="l01656"></a>01656         <span class="keyword">struct </span>sockaddr *addr = &amp;req-&gt;ifr_addr;
<a name="l01657"></a>01657         <span class="keywordflow">if</span> (<a class="code" href="../../dd/d8c/rubysocket_8h.html#a04da22756ad61ba67ddc856d5e0ebb40">IS_IP_FAMILY</a>(addr-&gt;sa_family)) {
<a name="l01658"></a>01658             <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(list, sockaddr_obj(addr));
<a name="l01659"></a>01659         }
<a name="l01660"></a>01660 <span class="preprocessor">#ifdef HAVE_SA_LEN</span>
<a name="l01661"></a>01661 <span class="preprocessor"></span><span class="preprocessor"># ifndef _SIZEOF_ADDR_IFREQ</span>
<a name="l01662"></a>01662 <span class="preprocessor"></span><span class="preprocessor">#  define _SIZEOF_ADDR_IFREQ(r) \</span>
<a name="l01663"></a>01663 <span class="preprocessor">          (sizeof(struct ifreq) + \</span>
<a name="l01664"></a>01664 <span class="preprocessor">           (sizeof(struct sockaddr) &lt; (r).ifr_addr.sa_len ? \</span>
<a name="l01665"></a>01665 <span class="preprocessor">            (r).ifr_addr.sa_len - sizeof(struct sockaddr) : \</span>
<a name="l01666"></a>01666 <span class="preprocessor">            0))</span>
<a name="l01667"></a>01667 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l01668"></a>01668 <span class="preprocessor"></span>        req = (<span class="keyword">struct </span>ifreq *)((<span class="keywordtype">char</span>*)req + _SIZEOF_ADDR_IFREQ(*req));
<a name="l01669"></a>01669 <span class="preprocessor">#else</span>
<a name="l01670"></a>01670 <span class="preprocessor"></span>        req = (<span class="keyword">struct </span>ifreq *)((<span class="keywordtype">char</span>*)req + <span class="keyword">sizeof</span>(<span class="keyword">struct </span>ifreq));
<a name="l01671"></a>01671 <span class="preprocessor">#endif</span>
<a name="l01672"></a>01672 <span class="preprocessor"></span>    }
<a name="l01673"></a>01673 
<a name="l01674"></a>01674   finish:
<a name="l01675"></a>01675 
<a name="l01676"></a>01676     save_errno = <a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a>;
<a name="l01677"></a>01677     <span class="keywordflow">if</span> (buf != initbuf)
<a name="l01678"></a>01678         <a class="code" href="../../d8/db0/defines_8h.html#a2c3897f7c46ca54a2e0dd7b24a40c7cb">xfree</a>(buf);
<a name="l01679"></a>01679     <span class="keywordflow">if</span> (fd != -1)
<a name="l01680"></a>01680         close(fd);
<a name="l01681"></a>01681     <a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a> = save_errno;
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     <span class="keywordflow">if</span> (reason)
<a name="l01684"></a>01684         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(reason);
<a name="l01685"></a>01685     <span class="keywordflow">return</span> list;
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 <span class="preprocessor">#undef EXTRA_SPACE</span>
<a name="l01688"></a>01688 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_WIN32)</span>
<a name="l01689"></a>01689 <span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keyword">struct </span>ip_adapter_unicast_address_st {
<a name="l01690"></a>01690         <span class="keywordtype">unsigned</span> LONG_LONG dummy0;
<a name="l01691"></a>01691         <span class="keyword">struct </span>ip_adapter_unicast_address_st *<a class="code" href="../../de/d32/dir_8c.html#a47fd7289dd70a0281a49f836c35c4817">Next</a>;
<a name="l01692"></a>01692         <span class="keyword">struct </span>{
<a name="l01693"></a>01693             <span class="keyword">struct </span>sockaddr *lpSockaddr;
<a name="l01694"></a>01694             <span class="keywordtype">int</span> iSockaddrLength;
<a name="l01695"></a>01695         } Address;
<a name="l01696"></a>01696         <span class="keywordtype">int</span> dummy1;
<a name="l01697"></a>01697         <span class="keywordtype">int</span> dummy2;
<a name="l01698"></a>01698         <span class="keywordtype">int</span> dummy3;
<a name="l01699"></a>01699         <span class="keywordtype">long</span> dummy4;
<a name="l01700"></a>01700         <span class="keywordtype">long</span> dummy5;
<a name="l01701"></a>01701         <span class="keywordtype">long</span> dummy6;
<a name="l01702"></a>01702     } ip_adapter_unicast_address_t;
<a name="l01703"></a>01703     <span class="keyword">typedef</span> <span class="keyword">struct </span>ip_adapter_anycast_address_st {
<a name="l01704"></a>01704         <span class="keywordtype">unsigned</span> LONG_LONG dummy0;
<a name="l01705"></a>01705         <span class="keyword">struct </span>ip_adapter_anycast_address_st *<a class="code" href="../../de/d32/dir_8c.html#a47fd7289dd70a0281a49f836c35c4817">Next</a>;
<a name="l01706"></a>01706         <span class="keyword">struct </span>{
<a name="l01707"></a>01707             <span class="keyword">struct </span>sockaddr *lpSockaddr;
<a name="l01708"></a>01708             <span class="keywordtype">int</span> iSockaddrLength;
<a name="l01709"></a>01709         } Address;
<a name="l01710"></a>01710     } ip_adapter_anycast_address_t;
<a name="l01711"></a>01711     <span class="keyword">typedef</span> <span class="keyword">struct </span>ip_adapter_addresses_st {
<a name="l01712"></a>01712         <span class="keywordtype">unsigned</span> LONG_LONG dummy0;
<a name="l01713"></a>01713         <span class="keyword">struct </span>ip_adapter_addresses_st *<a class="code" href="../../de/d32/dir_8c.html#a47fd7289dd70a0281a49f836c35c4817">Next</a>;
<a name="l01714"></a>01714         <span class="keywordtype">void</span> *dummy1;
<a name="l01715"></a>01715         ip_adapter_unicast_address_t *FirstUnicastAddress;
<a name="l01716"></a>01716         ip_adapter_anycast_address_t *FirstAnycastAddress;
<a name="l01717"></a>01717         <span class="keywordtype">void</span> *dummy2;
<a name="l01718"></a>01718         <span class="keywordtype">void</span> *dummy3;
<a name="l01719"></a>01719         <span class="keywordtype">void</span> *dummy4;
<a name="l01720"></a>01720         <span class="keywordtype">void</span> *dummy5;
<a name="l01721"></a>01721         <span class="keywordtype">void</span> *dummy6;
<a name="l01722"></a>01722         BYTE dummy7[8];
<a name="l01723"></a>01723         <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> dummy8;
<a name="l01724"></a>01724         <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> dummy9;
<a name="l01725"></a>01725         <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> dummy10;
<a name="l01726"></a>01726         <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> IfType;
<a name="l01727"></a>01727         <span class="keywordtype">int</span> OperStatus;
<a name="l01728"></a>01728         <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> dummy12;
<a name="l01729"></a>01729         <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> dummy13[16];
<a name="l01730"></a>01730         <span class="keywordtype">void</span> *dummy14;
<a name="l01731"></a>01731     } ip_adapter_addresses_t;
<a name="l01732"></a>01732     <span class="keyword">typedef</span> <a class="code" href="../../d2/d99/win32ole_8c.html#a516d92a41f815ad3c448380a9aa3e4d0">ULONG</a> (WINAPI *GetAdaptersAddresses_t)(<a class="code" href="../../d2/d99/win32ole_8c.html#a516d92a41f815ad3c448380a9aa3e4d0">ULONG</a>, ULONG, PVOID, ip_adapter_addresses_t *, PULONG);
<a name="l01733"></a>01733     HMODULE h;
<a name="l01734"></a>01734     GetAdaptersAddresses_t pGetAdaptersAddresses;
<a name="l01735"></a>01735     ULONG len;
<a name="l01736"></a>01736     <a class="code" href="../../d2/d99/win32ole_8c.html#a2ec0aeb209eda20f4bef5d50ce5a7417">DWORD</a> ret;
<a name="l01737"></a>01737     ip_adapter_addresses_t *adapters;
<a name="l01738"></a>01738     <a class="code" href="../../de/de6/ruby_2ruby_8h.html#a3c1d4bfc6a81af60bdcb48744c35f760">VALUE</a> list;
<a name="l01739"></a>01739 
<a name="l01740"></a>01740     h = LoadLibrary(<span class="stringliteral">&quot;iphlpapi.dll&quot;</span>);
<a name="l01741"></a>01741     <span class="keywordflow">if</span> (!h)
<a name="l01742"></a>01742         <a class="code" href="../../db/dcc/error_8c.html#a0083d327c582acc3300d59e8fe257c27">rb_notimplement</a>();
<a name="l01743"></a>01743     pGetAdaptersAddresses = (GetAdaptersAddresses_t)GetProcAddress(h, <span class="stringliteral">&quot;GetAdaptersAddresses&quot;</span>);
<a name="l01744"></a>01744     <span class="keywordflow">if</span> (!pGetAdaptersAddresses) {
<a name="l01745"></a>01745         FreeLibrary(h);
<a name="l01746"></a>01746         <a class="code" href="../../db/dcc/error_8c.html#a0083d327c582acc3300d59e8fe257c27">rb_notimplement</a>();
<a name="l01747"></a>01747     }
<a name="l01748"></a>01748 
<a name="l01749"></a>01749     ret = pGetAdaptersAddresses(<a class="code" href="../../d6/d07/sockport_8h.html#ae77ae24b14b7b7f294f3e04121173f12">AF_UNSPEC</a>, 0, NULL, NULL, &amp;len);
<a name="l01750"></a>01750     <span class="keywordflow">if</span> (ret != ERROR_SUCCESS &amp;&amp; ret != ERROR_BUFFER_OVERFLOW) {
<a name="l01751"></a>01751         <a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a> = <a class="code" href="../../dc/db1/win32_8h.html#a15f61b7f1beb4f88cca583894dcfefb9">rb_w32_map_errno</a>(ret);
<a name="l01752"></a>01752         FreeLibrary(h);
<a name="l01753"></a>01753         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;GetAdaptersAddresses&quot;</span>);
<a name="l01754"></a>01754     }
<a name="l01755"></a>01755     adapters = (ip_adapter_addresses_t *)<a class="code" href="../../de/de6/ruby_2ruby_8h.html#a1408f4b967485afd869990b67e766ceb">ALLOCA_N</a>(BYTE, len);
<a name="l01756"></a>01756     ret = pGetAdaptersAddresses(<a class="code" href="../../d6/d07/sockport_8h.html#ae77ae24b14b7b7f294f3e04121173f12">AF_UNSPEC</a>, 0, NULL, adapters, &amp;len);
<a name="l01757"></a>01757     <span class="keywordflow">if</span> (ret != ERROR_SUCCESS) {
<a name="l01758"></a>01758         <a class="code" href="../../d4/db0/__sdbm_8c.html#ad65a8842cc674e3ddf69355898c0ecbf">errno</a> = <a class="code" href="../../dc/db1/win32_8h.html#a15f61b7f1beb4f88cca583894dcfefb9">rb_w32_map_errno</a>(ret);
<a name="l01759"></a>01759         FreeLibrary(h);
<a name="l01760"></a>01760         <a class="code" href="../../da/d01/iconv_8c.html#aec8c58a2938d615c2e79659048c6ef60">rb_sys_fail</a>(<span class="stringliteral">&quot;GetAdaptersAddresses&quot;</span>);
<a name="l01761"></a>01761     }
<a name="l01762"></a>01762 
<a name="l01763"></a>01763     list = <a class="code" href="../../dc/dcc/array_8c.html#a9518114fd36cb4ef4656ec1dc63348c9">rb_ary_new</a>();
<a name="l01764"></a>01764     <span class="keywordflow">for</span> (; adapters; adapters = adapters-&gt;Next) {
<a name="l01765"></a>01765         ip_adapter_unicast_address_t *uni;
<a name="l01766"></a>01766         ip_adapter_anycast_address_t *any;
<a name="l01767"></a>01767         <span class="keywordflow">if</span> (adapters-&gt;OperStatus != 1)  <span class="comment">/* 1 means IfOperStatusUp */</span>
<a name="l01768"></a>01768             <span class="keywordflow">continue</span>;
<a name="l01769"></a>01769         <span class="keywordflow">for</span> (uni = adapters-&gt;FirstUnicastAddress; uni; uni = uni-&gt;Next) {
<a name="l01770"></a>01770 <span class="preprocessor">#ifndef INET6</span>
<a name="l01771"></a>01771 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (uni-&gt;Address.lpSockaddr-&gt;sa_family == AF_INET)
<a name="l01772"></a>01772 <span class="preprocessor">#else</span>
<a name="l01773"></a>01773 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (<a class="code" href="../../dd/d8c/rubysocket_8h.html#a04da22756ad61ba67ddc856d5e0ebb40">IS_IP_FAMILY</a>(uni-&gt;Address.lpSockaddr-&gt;sa_family))
<a name="l01774"></a>01774 <span class="preprocessor">#endif</span>
<a name="l01775"></a>01775 <span class="preprocessor"></span>                <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(list, sockaddr_obj(uni-&gt;Address.lpSockaddr));
<a name="l01776"></a>01776         }
<a name="l01777"></a>01777         <span class="keywordflow">for</span> (any = adapters-&gt;FirstAnycastAddress; any; any = any-&gt;Next) {
<a name="l01778"></a>01778 <span class="preprocessor">#ifndef INET6</span>
<a name="l01779"></a>01779 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (any-&gt;Address.lpSockaddr-&gt;sa_family == AF_INET)
<a name="l01780"></a>01780 <span class="preprocessor">#else</span>
<a name="l01781"></a>01781 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (<a class="code" href="../../dd/d8c/rubysocket_8h.html#a04da22756ad61ba67ddc856d5e0ebb40">IS_IP_FAMILY</a>(any-&gt;Address.lpSockaddr-&gt;sa_family))
<a name="l01782"></a>01782 <span class="preprocessor">#endif</span>
<a name="l01783"></a>01783 <span class="preprocessor"></span>                <a class="code" href="../../dc/dcc/array_8c.html#a59d553a8cd781364b8bcb0deae25cca2">rb_ary_push</a>(list, sockaddr_obj(any-&gt;Address.lpSockaddr));
<a name="l01784"></a>01784         }
<a name="l01785"></a>01785     }
<a name="l01786"></a>01786 
<a name="l01787"></a>01787     FreeLibrary(h);
<a name="l01788"></a>01788     <span class="keywordflow">return</span> list;
<a name="l01789"></a>01789 <span class="preprocessor">#endif</span>
<a name="l01790"></a>01790 <span class="preprocessor"></span>}
<a name="l01791"></a>01791 <span class="preprocessor">#else</span>
<a name="l01792"></a><a class="code" href="../../d5/df8/socket_8c.html#a645a96b8437b293856018e78049ccfb4">01792</a> <span class="preprocessor"></span><span class="preprocessor">#define socket_s_ip_address_list rb_f_notimplement</span>
<a name="l01793"></a>01793 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01794"></a>01794 <span class="preprocessor"></span>
<a name="l01795"></a>01795 <span class="keywordtype">void</span>
<a name="l01796"></a><a class="code" href="../../d5/df8/socket_8c.html#af026375a57a4241c5ab11ee11a739863">01796</a> <a class="code" href="../../d5/df8/socket_8c.html#af026375a57a4241c5ab11ee11a739863">Init_socket</a>()
<a name="l01797"></a>01797 {
<a name="l01798"></a>01798     <a class="code" href="../../d2/dbf/basicsocket_8c.html#acff2eff9bda1d7e8f978e8bce1ec22b4">rsock_init_basicsocket</a>();
<a name="l01799"></a>01799 
<a name="l01800"></a>01800     <span class="comment">/*</span>
<a name="l01801"></a>01801 <span class="comment">     * Document-class: Socket &lt; BasicSocket</span>
<a name="l01802"></a>01802 <span class="comment">     *</span>
<a name="l01803"></a>01803 <span class="comment">     * Class +Socket+ provides access to the underlying operating system</span>
<a name="l01804"></a>01804 <span class="comment">     * socket implementations.  It can be used to provide more operating system</span>
<a name="l01805"></a>01805 <span class="comment">     * specific functionality than the protocol-specific socket classes.</span>
<a name="l01806"></a>01806 <span class="comment">     *</span>
<a name="l01807"></a>01807 <span class="comment">     * The constants defined under Socket::Constants are also defined under</span>
<a name="l01808"></a>01808 <span class="comment">     * Socket.  For example, Socket::AF_INET is usable as well as</span>
<a name="l01809"></a>01809 <span class="comment">     * Socket::Constants::AF_INET.  See Socket::Constants for the list of</span>
<a name="l01810"></a>01810 <span class="comment">     * constants.</span>
<a name="l01811"></a>01811 <span class="comment">     *</span>
<a name="l01812"></a>01812 <span class="comment">     * === What&apos;s a socket?</span>
<a name="l01813"></a>01813 <span class="comment">     *</span>
<a name="l01814"></a>01814 <span class="comment">     * Sockets are endpoints of a bidirectionnal communication channel.</span>
<a name="l01815"></a>01815 <span class="comment">     * Sockets can communicate within a process, between processes on the same</span>
<a name="l01816"></a>01816 <span class="comment">     * machine or between different machines.  There are many types of socket:</span>
<a name="l01817"></a>01817 <span class="comment">     * TCPSocket, UDPSocket or UNIXSocket for example.</span>
<a name="l01818"></a>01818 <span class="comment">     *</span>
<a name="l01819"></a>01819 <span class="comment">     * Sockets have their own vocabulary:</span>
<a name="l01820"></a>01820 <span class="comment">     * domain::</span>
<a name="l01821"></a>01821 <span class="comment">     *   The family of protocols:  Socket::PF_INET, Socket::PF_INET6,</span>
<a name="l01822"></a>01822 <span class="comment">     *   Socket::PF_UNIX, etc.</span>
<a name="l01823"></a>01823 <span class="comment">     * type::</span>
<a name="l01824"></a>01824 <span class="comment">     *   The type of communications between the two endpoints, typically</span>
<a name="l01825"></a>01825 <span class="comment">     *   Socket::SOCK_STREAM or Socket::SOCK_DGRAM.</span>
<a name="l01826"></a>01826 <span class="comment">     * protocol::</span>
<a name="l01827"></a>01827 <span class="comment">     *   Typically zero.  This may be used to identify a variant of a</span>
<a name="l01828"></a>01828 <span class="comment">     *   protocol.</span>
<a name="l01829"></a>01829 <span class="comment">     * hostname::</span>
<a name="l01830"></a>01830 <span class="comment">     *   The identifier of a network interface:</span>
<a name="l01831"></a>01831 <span class="comment">     *     * a string (hostname, IPv4 or IPv6 adress or &lt;tt&gt;&lt;broadcast&gt;&lt;/tt&gt;</span>
<a name="l01832"></a>01832 <span class="comment">     *       which specifies a broadcast address)</span>
<a name="l01833"></a>01833 <span class="comment">     *     * a zero-length string which specifies INADDR_ANY</span>
<a name="l01834"></a>01834 <span class="comment">     *     * an integer (interpreted as binary address in host byte order).</span>
<a name="l01835"></a>01835 <span class="comment">     *</span>
<a name="l01836"></a>01836 <span class="comment">     * === Quick start</span>
<a name="l01837"></a>01837 <span class="comment">     *</span>
<a name="l01838"></a>01838 <span class="comment">     * Some classes such as TCPSocket, UDPSocket or UNIXSocket ease use of</span>
<a name="l01839"></a>01839 <span class="comment">     * sockets of these types compared to C programming.</span>
<a name="l01840"></a>01840 <span class="comment">     *</span>
<a name="l01841"></a>01841 <span class="comment">     *   # Creating a TCP socket in a C-like manner</span>
<a name="l01842"></a>01842 <span class="comment">     *   s = Socket.new Socket::INET, Socket::SOCK_STREAM</span>
<a name="l01843"></a>01843 <span class="comment">     *   s.connect Socket.pack_sockaddr_in(80, &apos;example.com&apos;)</span>
<a name="l01844"></a>01844 <span class="comment">     *</span>
<a name="l01845"></a>01845 <span class="comment">     *   # Using TCPSocket</span>
<a name="l01846"></a>01846 <span class="comment">     *   s = TCPSocket.new &apos;example.com&apos;, 80</span>
<a name="l01847"></a>01847 <span class="comment">     *</span>
<a name="l01848"></a>01848 <span class="comment">     * A simple server would look like:</span>
<a name="l01849"></a>01849 <span class="comment">     *</span>
<a name="l01850"></a>01850 <span class="comment">     *   require &apos;socket&apos;</span>
<a name="l01851"></a>01851 <span class="comment">     *</span>
<a name="l01852"></a>01852 <span class="comment">     *   server = TCPServer.new 2000 # Server bound to port 2000</span>
<a name="l01853"></a>01853 <span class="comment">     *</span>
<a name="l01854"></a>01854 <span class="comment">     *   loop do</span>
<a name="l01855"></a>01855 <span class="comment">     *     client = server.accept    # Wait for a client to connect</span>
<a name="l01856"></a>01856 <span class="comment">     *     client.puts &quot;Hello !&quot;</span>
<a name="l01857"></a>01857 <span class="comment">     *     client.puts &quot;Time is #{Time.now}&quot;</span>
<a name="l01858"></a>01858 <span class="comment">     *     client.close</span>
<a name="l01859"></a>01859 <span class="comment">     *   end</span>
<a name="l01860"></a>01860 <span class="comment">     *</span>
<a name="l01861"></a>01861 <span class="comment">     * A simple client may look like:</span>
<a name="l01862"></a>01862 <span class="comment">     *</span>
<a name="l01863"></a>01863 <span class="comment">     *   require &apos;socket&apos;</span>
<a name="l01864"></a>01864 <span class="comment">     *</span>
<a name="l01865"></a>01865 <span class="comment">     *   s = TCPSocket.new &apos;localhost&apos;, 2000</span>
<a name="l01866"></a>01866 <span class="comment">     *</span>
<a name="l01867"></a>01867 <span class="comment">     *   while line = s.gets # Read lines from socket</span>
<a name="l01868"></a>01868 <span class="comment">     *     puts line         # and print them</span>
<a name="l01869"></a>01869 <span class="comment">     *   end</span>
<a name="l01870"></a>01870 <span class="comment">     *</span>
<a name="l01871"></a>01871 <span class="comment">     *   s.close             # close socket when done</span>
<a name="l01872"></a>01872 <span class="comment">     *</span>
<a name="l01873"></a>01873 <span class="comment">     * === Exception Handling</span>
<a name="l01874"></a>01874 <span class="comment">     *</span>
<a name="l01875"></a>01875 <span class="comment">     * Ruby&apos;s Socket implementation raises exceptions based on the error</span>
<a name="l01876"></a>01876 <span class="comment">     * generated by the system dependent implementation.  This is why the</span>
<a name="l01877"></a>01877 <span class="comment">     * methods are documented in a way that isolate Unix-based system</span>
<a name="l01878"></a>01878 <span class="comment">     * exceptions from Windows based exceptions. If more information on</span>
<a name="l01879"></a>01879 <span class="comment">     * particular exception is needed please refer to the Unix manual pages or</span>
<a name="l01880"></a>01880 <span class="comment">     * the Windows WinSock reference.</span>
<a name="l01881"></a>01881 <span class="comment">     *</span>
<a name="l01882"></a>01882 <span class="comment">     * === Convenient methods</span>
<a name="l01883"></a>01883 <span class="comment">     *</span>
<a name="l01884"></a>01884 <span class="comment">     * Although the general way to create socket is Socket.new,</span>
<a name="l01885"></a>01885 <span class="comment">     * there are several methods for socket creation for most cases.</span>
<a name="l01886"></a>01886 <span class="comment">     *</span>
<a name="l01887"></a>01887 <span class="comment">     * TCP client socket::</span>
<a name="l01888"></a>01888 <span class="comment">     *   Socket.tcp, TCPSocket.open</span>
<a name="l01889"></a>01889 <span class="comment">     * TCP server socket::</span>
<a name="l01890"></a>01890 <span class="comment">     *   Socket.tcp_server_loop, TCPServer.open</span>
<a name="l01891"></a>01891 <span class="comment">     * UNIX client socket::</span>
<a name="l01892"></a>01892 <span class="comment">     *   Socket.unix, UNIXSocket.open</span>
<a name="l01893"></a>01893 <span class="comment">     * UNIX server socket::</span>
<a name="l01894"></a>01894 <span class="comment">     *   Socket.unix_server_loop, UNIXServer.open</span>
<a name="l01895"></a>01895 <span class="comment">     *</span>
<a name="l01896"></a>01896 <span class="comment">     * === Documentation by</span>
<a name="l01897"></a>01897 <span class="comment">     *</span>
<a name="l01898"></a>01898 <span class="comment">     * * Zach Dennis</span>
<a name="l01899"></a>01899 <span class="comment">     * * Sam Roberts</span>
<a name="l01900"></a>01900 <span class="comment">     * * &lt;em&gt;Programming Ruby&lt;/em&gt; from The Pragmatic Bookshelf.</span>
<a name="l01901"></a>01901 <span class="comment">     *</span>
<a name="l01902"></a>01902 <span class="comment">     * Much material in this documentation is taken with permission from</span>
<a name="l01903"></a>01903 <span class="comment">     * &lt;em&gt;Programming Ruby&lt;/em&gt; from The Pragmatic Bookshelf.</span>
<a name="l01904"></a>01904 <span class="comment">     */</span>
<a name="l01905"></a>01905     <a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a> = <a class="code" href="../../de/ddf/group__class.html#ga15d068dbe88a3bab3700b03bebb7fbac" title="Defines a top-level class.">rb_define_class</a>(<span class="stringliteral">&quot;Socket&quot;</span>, <a class="code" href="../../da/dcc/socket_2init_8c.html#af24f10d27424134ec1c036ab38c98e13">rb_cBasicSocket</a>);
<a name="l01906"></a>01906 
<a name="l01907"></a>01907     <a class="code" href="../../da/dcc/socket_2init_8c.html#a494bd9a98a3765a0d686800ed9383f7e">rsock_init_socket_init</a>();
<a name="l01908"></a>01908 
<a name="l01909"></a>01909     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;initialize&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#ac836eb0f162ea2797f923d768002e6db">sock_initialize</a>, -1);
<a name="l01910"></a>01910     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;connect&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#ae85c71a1788d42c28521462616cc894a">sock_connect</a>, 1);
<a name="l01911"></a>01911     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;connect_nonblock&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a0b3a834fdc9dc7f0621e382111736ec4">sock_connect_nonblock</a>, 1);
<a name="l01912"></a>01912     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;bind&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a7a596462d1d632b3d82710985bb1c86f">sock_bind</a>, 1);
<a name="l01913"></a>01913     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;listen&quot;</span>, <a class="code" href="../../dd/d8c/rubysocket_8h.html#acd4ebfc5cf43a6c4148cce15ada4cce3">rsock_sock_listen</a>, 1);
<a name="l01914"></a>01914     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;accept&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a44e27a97a613e0a533847d3877d7fd82">sock_accept</a>, 0);
<a name="l01915"></a>01915     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;accept_nonblock&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a5bbe0a5dbdecc04e8d001f3143a57c08">sock_accept_nonblock</a>, 0);
<a name="l01916"></a>01916     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;sysaccept&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#aaf11817ffe09f2f8293510379eebee08">sock_sysaccept</a>, 0);
<a name="l01917"></a>01917 
<a name="l01918"></a>01918     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;recvfrom&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a292a68788435551b78a4c7a80c37b613">sock_recvfrom</a>, -1);
<a name="l01919"></a>01919     <a class="code" href="../../d7/d19/group__defmethod.html#ga118dc7abcdb97f56fe35727ac0ff6eb8">rb_define_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;recvfrom_nonblock&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a7995bb0bb548f0a3b9a05094f431647e">sock_recvfrom_nonblock</a>, -1);
<a name="l01920"></a>01920 
<a name="l01921"></a>01921     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;socketpair&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a0627676d0b2c7f5831f2f42e482f531e">rsock_sock_s_socketpair</a>, -1);
<a name="l01922"></a>01922     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;pair&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a0627676d0b2c7f5831f2f42e482f531e">rsock_sock_s_socketpair</a>, -1);
<a name="l01923"></a>01923     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;gethostname&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a90588fae9887bf7bededce0c899637d3">sock_gethostname</a>, 0);
<a name="l01924"></a>01924     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;gethostbyname&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a74e98327125c7d7cedde4fe8083352e3">sock_s_gethostbyname</a>, 1);
<a name="l01925"></a>01925     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;gethostbyaddr&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a2cfaf4e1082fd7d24c311d88605eee55">sock_s_gethostbyaddr</a>, -1);
<a name="l01926"></a>01926     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;getservbyname&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a4f788d571ef0509aed6be9ba9d432ee8">sock_s_getservbyname</a>, -1);
<a name="l01927"></a>01927     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;getservbyport&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a07ee947073d4cf75f43108199b60d656">sock_s_getservbyport</a>, -1);
<a name="l01928"></a>01928     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;getaddrinfo&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a369470d491264ba274dc3d7af5e2df4b">sock_s_getaddrinfo</a>, -1);
<a name="l01929"></a>01929     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;getnameinfo&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#af906a5a77f166216f5ea9e51e4a31358">sock_s_getnameinfo</a>, -1);
<a name="l01930"></a>01930     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;sockaddr_in&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a0f707cf61887572d6318b4e021123e05">sock_s_pack_sockaddr_in</a>, 2);
<a name="l01931"></a>01931     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;pack_sockaddr_in&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a0f707cf61887572d6318b4e021123e05">sock_s_pack_sockaddr_in</a>, 2);
<a name="l01932"></a>01932     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;unpack_sockaddr_in&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a3c331cf971119ac51778a5bb4707a447">sock_s_unpack_sockaddr_in</a>, 1);
<a name="l01933"></a>01933 <span class="preprocessor">#ifdef HAVE_SYS_UN_H</span>
<a name="l01934"></a>01934 <span class="preprocessor"></span>    <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;sockaddr_un&quot;</span>, sock_s_pack_sockaddr_un, 1);
<a name="l01935"></a>01935     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;pack_sockaddr_un&quot;</span>, sock_s_pack_sockaddr_un, 1);
<a name="l01936"></a>01936     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;unpack_sockaddr_un&quot;</span>, sock_s_unpack_sockaddr_un, 1);
<a name="l01937"></a>01937 <span class="preprocessor">#endif</span>
<a name="l01938"></a>01938 <span class="preprocessor"></span>
<a name="l01939"></a>01939     <a class="code" href="../../d7/d19/group__defmethod.html#gaacfe6a2ec444bdc7f573afb75ea251fe" title="Defines a singleton method for obj.">rb_define_singleton_method</a>(<a class="code" href="../../da/dcc/socket_2init_8c.html#ae6ab6b9765b61f4e361b67dd00328014">rb_cSocket</a>, <span class="stringliteral">&quot;ip_address_list&quot;</span>, <a class="code" href="../../d5/df8/socket_8c.html#a645a96b8437b293856018e78049ccfb4">socket_s_ip_address_list</a>, 0);
<a name="l01940"></a>01940 }
<a name="l01941"></a>01941 
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Mar 2013 for Ruby by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
